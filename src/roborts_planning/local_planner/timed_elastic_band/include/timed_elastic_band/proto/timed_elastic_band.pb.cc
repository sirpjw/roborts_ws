// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#include "timed_elastic_band.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace roborts_local_planner {
PROTOBUF_CONSTEXPR FrameID::FrameID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.odom_frame_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_frame_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct FrameIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameIDDefaultTypeInternal() {}
  union {
    FrameID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameIDDefaultTypeInternal _FrameID_default_instance_;
PROTOBUF_CONSTEXPR Point2D::Point2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct Point2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Point2DDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Point2DDefaultTypeInternal() {}
  union {
    Point2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Point2DDefaultTypeInternal _Point2D_default_instance_;
PROTOBUF_CONSTEXPR Trajectory::Trajectory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dt_ref_)*/0
  , /*decltype(_impl_.dt_hysteresis_)*/0
  , /*decltype(_impl_.teb_autosize_)*/false
  , /*decltype(_impl_.global_plan_overwrite_orientation_)*/false
  , /*decltype(_impl_.allow_init_with_backwards_motion_)*/false
  , /*decltype(_impl_.via_points_ordered_)*/false
  , /*decltype(_impl_.global_plan_viapoint_sep_)*/0
  , /*decltype(_impl_.max_global_plan_lookahead_dist_)*/0
  , /*decltype(_impl_.force_reinit_new_goal_dist_)*/0
  , /*decltype(_impl_.feasibility_check_no_poses_)*/int64_t{0}
  , /*decltype(_impl_.min_samples_)*/int64_t{0}
  , /*decltype(_impl_.max_samples_)*/int64_t{0}
  , /*decltype(_impl_.exact_arc_length_)*/false
  , /*decltype(_impl_.publish_feedback_)*/false} {}
struct TrajectoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrajectoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrajectoryDefaultTypeInternal() {}
  union {
    Trajectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
PROTOBUF_CONSTEXPR FootprintModel::FootprintModel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.robot_vertices_)*/{}
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.front_offset_)*/0
  , /*decltype(_impl_.front_radius_)*/0
  , /*decltype(_impl_.rear_offset_)*/0
  , /*decltype(_impl_.rear_radius_)*/0
  , /*decltype(_impl_.type_)*/0} {}
struct FootprintModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FootprintModelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FootprintModelDefaultTypeInternal() {}
  union {
    FootprintModel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FootprintModelDefaultTypeInternal _FootprintModel_default_instance_;
PROTOBUF_CONSTEXPR Robot::Robot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.max_vel_x_)*/0
  , /*decltype(_impl_.max_vel_x_backwards_)*/0
  , /*decltype(_impl_.max_vel_y_)*/0
  , /*decltype(_impl_.max_vel_theta_)*/0
  , /*decltype(_impl_.acc_lim_x_)*/0
  , /*decltype(_impl_.acc_lim_y_)*/0
  , /*decltype(_impl_.acc_lim_theta_)*/0
  , /*decltype(_impl_.min_turning_radius_)*/0
  , /*decltype(_impl_.wheelbase_)*/0
  , /*decltype(_impl_.cmd_angle_instead_rotvel_)*/false} {}
struct RobotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotDefaultTypeInternal() {}
  union {
    Robot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotDefaultTypeInternal _Robot_default_instance_;
PROTOBUF_CONSTEXPR GoalTolerance::GoalTolerance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.xy_goal_tolerance_)*/0
  , /*decltype(_impl_.yaw_goal_tolerance_)*/0
  , /*decltype(_impl_.free_goal_vel_)*/false} {}
struct GoalToleranceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GoalToleranceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GoalToleranceDefaultTypeInternal() {}
  union {
    GoalTolerance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GoalToleranceDefaultTypeInternal _GoalTolerance_default_instance_;
PROTOBUF_CONSTEXPR Obstacles::Obstacles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.costmap_converter_plugin_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.min_obstacle_dist_)*/0
  , /*decltype(_impl_.inflation_dist_)*/0
  , /*decltype(_impl_.costmap_obstacles_behind_robot_dist_)*/0
  , /*decltype(_impl_.obstacle_poses_affected_)*/0
  , /*decltype(_impl_.include_costmap_obstacles_)*/false
  , /*decltype(_impl_.legacy_obstacle_association_)*/false
  , /*decltype(_impl_.costmap_converter_spin_thread_)*/false
  , /*decltype(_impl_.obstacle_association_cutoff_factor_)*/0
  , /*decltype(_impl_.obstacle_association_force_inclusion_factor_)*/0
  , /*decltype(_impl_.costmap_converter_rate_)*/0} {}
struct ObstaclesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObstaclesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObstaclesDefaultTypeInternal() {}
  union {
    Obstacles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
PROTOBUF_CONSTEXPR Optimization::Optimization(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.no_inner_iterations_)*/0
  , /*decltype(_impl_.no_outer_iterations_)*/0
  , /*decltype(_impl_.optimization_activate_)*/false
  , /*decltype(_impl_.optimization_verbose_)*/false
  , /*decltype(_impl_.penalty_epsilon_)*/0
  , /*decltype(_impl_.weight_max_vel_x_)*/0
  , /*decltype(_impl_.weight_max_vel_y_)*/0
  , /*decltype(_impl_.weight_max_vel_theta_)*/0
  , /*decltype(_impl_.weight_acc_lim_x_)*/0
  , /*decltype(_impl_.weight_acc_lim_y_)*/0
  , /*decltype(_impl_.weight_acc_lim_thet_)*/0
  , /*decltype(_impl_.weight_kinematics_nh_)*/0
  , /*decltype(_impl_.weight_kinematics_forward_drive_)*/0
  , /*decltype(_impl_.weight_kinematics_turning_radius_)*/0
  , /*decltype(_impl_.weight_optimaltime_)*/0
  , /*decltype(_impl_.weight_obstacle_)*/0
  , /*decltype(_impl_.weight_inflation_)*/0
  , /*decltype(_impl_.weight_dynamic_obstacle_)*/0
  , /*decltype(_impl_.weight_viapoint_)*/0
  , /*decltype(_impl_.weight_adapt_factor_)*/0
  , /*decltype(_impl_.weight_prefer_rotdir_)*/0
  , /*decltype(_impl_.weight_acc_lim_theta_)*/0} {}
struct OptimizationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptimizationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptimizationDefaultTypeInternal() {}
  union {
    Optimization _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationDefaultTypeInternal _Optimization_default_instance_;
PROTOBUF_CONSTEXPR HomotopyClassPlanner::HomotopyClassPlanner(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_homotopy_class_planning_)*/false
  , /*decltype(_impl_.enable_multithreading_)*/false
  , /*decltype(_impl_.simple_exploration_)*/false
  , /*decltype(_impl_.selection_alternative_time_cost_)*/false
  , /*decltype(_impl_.max_number_classes_)*/0
  , /*decltype(_impl_.selection_obst_cost_scale_)*/0
  , /*decltype(_impl_.selection_prefer_initial_plan_)*/0
  , /*decltype(_impl_.selection_viapoint_cost_scale_)*/0
  , /*decltype(_impl_.selection_cost_hysteresis_)*/0
  , /*decltype(_impl_.roadmap_graph_no_samples_)*/0
  , /*decltype(_impl_.roadmap_graph_area_width_)*/0
  , /*decltype(_impl_.roadmap_graph_area_length_scale_)*/0
  , /*decltype(_impl_.h_signature_prescaler_)*/0
  , /*decltype(_impl_.h_signature_threshold_)*/0
  , /*decltype(_impl_.obstacle_keypoint_offset_)*/0
  , /*decltype(_impl_.obstacle_heading_threshold_)*/0
  , /*decltype(_impl_.viapoints_all_candidates_)*/false
  , /*decltype(_impl_.visualize_hc_graph_)*/false} {}
struct HomotopyClassPlannerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HomotopyClassPlannerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HomotopyClassPlannerDefaultTypeInternal() {}
  union {
    HomotopyClassPlanner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HomotopyClassPlannerDefaultTypeInternal _HomotopyClassPlanner_default_instance_;
PROTOBUF_CONSTEXPR Recovery::Recovery(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.oscillation_v_eps_)*/0
  , /*decltype(_impl_.oscillation_omega_eps_)*/0
  , /*decltype(_impl_.oscillation_recovery_min_duration_)*/0
  , /*decltype(_impl_.oscillation_filter_duration_)*/0
  , /*decltype(_impl_.shrink_horizon_min_duration_)*/false
  , /*decltype(_impl_.oscillation_recovery_)*/false
  , /*decltype(_impl_.shrink_horizon_backup_)*/false} {}
struct RecoveryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoveryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoveryDefaultTypeInternal() {}
  union {
    Recovery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoveryDefaultTypeInternal _Recovery_default_instance_;
PROTOBUF_CONSTEXPR Config::Config(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.robot_type_)*/{}
  , /*decltype(_impl_.opt_frame_)*/nullptr
  , /*decltype(_impl_.trajectory_opt_)*/nullptr
  , /*decltype(_impl_.kinematics_opt_)*/nullptr
  , /*decltype(_impl_.tolerance_opt_)*/nullptr
  , /*decltype(_impl_.obstacles_opt_)*/nullptr
  , /*decltype(_impl_.optimize_info_)*/nullptr
  , /*decltype(_impl_.hcp_opt_)*/nullptr
  , /*decltype(_impl_.recovery_info_)*/nullptr} {}
struct ConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigDefaultTypeInternal() {}
  union {
    Config _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigDefaultTypeInternal _Config_default_instance_;
}  // namespace roborts_local_planner
static ::_pb::Metadata file_level_metadata_timed_5felastic_5fband_2eproto[11];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_timed_5felastic_5fband_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_timed_5felastic_5fband_2eproto = nullptr;

const uint32_t TableStruct_timed_5felastic_5fband_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FrameID, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FrameID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FrameID, _impl_.odom_frame_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FrameID, _impl_.map_frame_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Point2D, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Point2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Point2D, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Point2D, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.teb_autosize_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.dt_ref_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.dt_hysteresis_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.global_plan_overwrite_orientation_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.allow_init_with_backwards_motion_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.global_plan_viapoint_sep_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.via_points_ordered_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.max_global_plan_lookahead_dist_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.exact_arc_length_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.force_reinit_new_goal_dist_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.feasibility_check_no_poses_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.publish_feedback_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.min_samples_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Trajectory, _impl_.max_samples_),
  2,
  0,
  1,
  3,
  4,
  6,
  5,
  7,
  12,
  8,
  9,
  13,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.front_offset_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.front_radius_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.rear_offset_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.rear_radius_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::FootprintModel, _impl_.robot_vertices_),
  5,
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.max_vel_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.max_vel_x_backwards_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.max_vel_y_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.max_vel_theta_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.acc_lim_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.acc_lim_y_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.acc_lim_theta_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.min_turning_radius_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.wheelbase_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Robot, _impl_.cmd_angle_instead_rotvel_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::GoalTolerance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::GoalTolerance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::GoalTolerance, _impl_.xy_goal_tolerance_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::GoalTolerance, _impl_.yaw_goal_tolerance_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::GoalTolerance, _impl_.free_goal_vel_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.min_obstacle_dist_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.inflation_dist_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.include_costmap_obstacles_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.costmap_obstacles_behind_robot_dist_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.obstacle_poses_affected_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.legacy_obstacle_association_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.obstacle_association_cutoff_factor_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.obstacle_association_force_inclusion_factor_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.costmap_converter_plugin_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.costmap_converter_spin_thread_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Obstacles, _impl_.costmap_converter_rate_),
  1,
  2,
  5,
  3,
  4,
  6,
  8,
  9,
  0,
  7,
  10,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.no_inner_iterations_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.no_outer_iterations_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.optimization_activate_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.optimization_verbose_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.penalty_epsilon_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_max_vel_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_max_vel_y_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_max_vel_theta_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_acc_lim_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_acc_lim_y_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_acc_lim_thet_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_kinematics_nh_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_kinematics_forward_drive_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_kinematics_turning_radius_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_optimaltime_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_obstacle_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_inflation_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_dynamic_obstacle_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_viapoint_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_adapt_factor_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_prefer_rotdir_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Optimization, _impl_.weight_acc_lim_theta_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.enable_homotopy_class_planning_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.enable_multithreading_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.simple_exploration_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.max_number_classes_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.selection_obst_cost_scale_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.selection_prefer_initial_plan_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.selection_viapoint_cost_scale_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.selection_cost_hysteresis_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.selection_alternative_time_cost_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.roadmap_graph_no_samples_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.roadmap_graph_area_width_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.roadmap_graph_area_length_scale_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.h_signature_prescaler_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.h_signature_threshold_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.obstacle_keypoint_offset_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.obstacle_heading_threshold_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.viapoints_all_candidates_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::HomotopyClassPlanner, _impl_.visualize_hc_graph_),
  0,
  1,
  2,
  4,
  5,
  6,
  7,
  8,
  3,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.shrink_horizon_min_duration_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.oscillation_recovery_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.shrink_horizon_backup_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.oscillation_v_eps_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.oscillation_omega_eps_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.oscillation_recovery_min_duration_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Recovery, _impl_.oscillation_filter_duration_),
  4,
  5,
  6,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.opt_frame_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.trajectory_opt_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.kinematics_opt_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.tolerance_opt_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.obstacles_opt_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.optimize_info_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.hcp_opt_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.robot_type_),
  PROTOBUF_FIELD_OFFSET(::roborts_local_planner::Config, _impl_.recovery_info_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  7,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::roborts_local_planner::FrameID)},
  { 10, 18, -1, sizeof(::roborts_local_planner::Point2D)},
  { 20, 40, -1, sizeof(::roborts_local_planner::Trajectory)},
  { 54, 67, -1, sizeof(::roborts_local_planner::FootprintModel)},
  { 74, 90, -1, sizeof(::roborts_local_planner::Robot)},
  { 100, 109, -1, sizeof(::roborts_local_planner::GoalTolerance)},
  { 112, 129, -1, sizeof(::roborts_local_planner::Obstacles)},
  { 140, 168, -1, sizeof(::roborts_local_planner::Optimization)},
  { 190, 214, -1, sizeof(::roborts_local_planner::HomotopyClassPlanner)},
  { 232, 245, -1, sizeof(::roborts_local_planner::Recovery)},
  { 252, 267, -1, sizeof(::roborts_local_planner::Config)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::roborts_local_planner::_FrameID_default_instance_._instance,
  &::roborts_local_planner::_Point2D_default_instance_._instance,
  &::roborts_local_planner::_Trajectory_default_instance_._instance,
  &::roborts_local_planner::_FootprintModel_default_instance_._instance,
  &::roborts_local_planner::_Robot_default_instance_._instance,
  &::roborts_local_planner::_GoalTolerance_default_instance_._instance,
  &::roborts_local_planner::_Obstacles_default_instance_._instance,
  &::roborts_local_planner::_Optimization_default_instance_._instance,
  &::roborts_local_planner::_HomotopyClassPlanner_default_instance_._instance,
  &::roborts_local_planner::_Recovery_default_instance_._instance,
  &::roborts_local_planner::_Config_default_instance_._instance,
};

const char descriptor_table_protodef_timed_5felastic_5fband_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030timed_elastic_band.proto\022\025roborts_loca"
  "l_planner\"0\n\007FrameID\022\022\n\nodom_frame\030\001 \001(\t"
  "\022\021\n\tmap_frame\030\002 \001(\t\"\037\n\007Point2D\022\t\n\001x\030\001 \001("
  "\002\022\t\n\001y\030\002 \001(\002\"\252\003\n\nTrajectory\022\024\n\014teb_autos"
  "ize\030\001 \001(\010\022\016\n\006dt_ref\030\002 \001(\002\022\025\n\rdt_hysteres"
  "is\030\003 \001(\002\022)\n!global_plan_overwrite_orient"
  "ation\030\004 \001(\010\022(\n allow_init_with_backwards"
  "_motion\030\005 \001(\010\022 \n\030global_plan_viapoint_se"
  "p\030\006 \001(\002\022\032\n\022via_points_ordered\030\007 \001(\010\022&\n\036m"
  "ax_global_plan_lookahead_dist\030\010 \001(\002\022\030\n\020e"
  "xact_arc_length\030\t \001(\010\022\"\n\032force_reinit_ne"
  "w_goal_dist\030\n \001(\002\022\"\n\032feasibility_check_n"
  "o_poses\030\013 \001(\003\022\030\n\020publish_feedback\030\014 \001(\010\022"
  "\023\n\013min_samples\030\r \001(\003\022\023\n\013max_samples\030\016 \001("
  "\003\"\302\002\n\016FootprintModel\022A\n\004type\030\001 \001(\01623.rob"
  "orts_local_planner.FootprintModel.Footpr"
  "intType\022\016\n\006radius\030\002 \001(\001\022\024\n\014front_offset\030"
  "\003 \001(\001\022\024\n\014front_radius\030\004 \001(\001\022\023\n\013rear_offs"
  "et\030\005 \001(\001\022\023\n\013rear_radius\030\006 \001(\001\0226\n\016robot_v"
  "ertices\030\007 \003(\0132\036.roborts_local_planner.Po"
  "int2D\"O\n\rFootprintType\022\t\n\005POINT\020\000\022\014\n\010CIR"
  "CULAR\020\001\022\016\n\nTWOCIRCLES\020\002\022\010\n\004LINE\020\003\022\013\n\007POL"
  "YGON\020\004\"\357\001\n\005Robot\022\021\n\tmax_vel_x\030\001 \001(\002\022\033\n\023m"
  "ax_vel_x_backwards\030\002 \001(\002\022\021\n\tmax_vel_y\030\003 "
  "\001(\002\022\025\n\rmax_vel_theta\030\004 \001(\002\022\021\n\tacc_lim_x\030"
  "\005 \001(\002\022\021\n\tacc_lim_y\030\006 \001(\002\022\025\n\racc_lim_thet"
  "a\030\007 \001(\002\022\032\n\022min_turning_radius\030\010 \001(\002\022\021\n\tw"
  "heelbase\030\t \001(\002\022 \n\030cmd_angle_instead_rotv"
  "el\030\n \001(\010\"]\n\rGoalTolerance\022\031\n\021xy_goal_tol"
  "erance\030\001 \001(\002\022\032\n\022yaw_goal_tolerance\030\002 \001(\002"
  "\022\025\n\rfree_goal_vel\030\003 \001(\010\"\236\003\n\tObstacles\022\031\n"
  "\021min_obstacle_dist\030\001 \001(\002\022\026\n\016inflation_di"
  "st\030\002 \001(\002\022!\n\031include_costmap_obstacles\030\003 "
  "\001(\010\022+\n#costmap_obstacles_behind_robot_di"
  "st\030\004 \001(\002\022\037\n\027obstacle_poses_affected\030\005 \001("
  "\002\022#\n\033legacy_obstacle_association\030\006 \001(\010\022*"
  "\n\"obstacle_association_cutoff_factor\030\007 \001"
  "(\002\0223\n+obstacle_association_force_inclusi"
  "on_factor\030\010 \001(\002\022 \n\030costmap_converter_plu"
  "gin\030\t \001(\t\022%\n\035costmap_converter_spin_thre"
  "ad\030\n \001(\010\022\036\n\026costmap_converter_rate\030\013 \001(\002"
  "\"\224\005\n\014Optimization\022\033\n\023no_inner_iterations"
  "\030\001 \001(\005\022\033\n\023no_outer_iterations\030\002 \001(\005\022\035\n\025o"
  "ptimization_activate\030\003 \001(\010\022\034\n\024optimizati"
  "on_verbose\030\004 \001(\010\022\027\n\017penalty_epsilon\030\005 \001("
  "\002\022\030\n\020weight_max_vel_x\030\006 \001(\002\022\030\n\020weight_ma"
  "x_vel_y\030\007 \001(\002\022\034\n\024weight_max_vel_theta\030\010 "
  "\001(\002\022\030\n\020weight_acc_lim_x\030\t \001(\002\022\030\n\020weight_"
  "acc_lim_y\030\n \001(\002\022\033\n\023weight_acc_lim_thet\030\013"
  " \001(\002\022\034\n\024weight_kinematics_nh\030\014 \001(\002\022\'\n\037we"
  "ight_kinematics_forward_drive\030\r \001(\002\022(\n w"
  "eight_kinematics_turning_radius\030\016 \001(\002\022\032\n"
  "\022weight_optimaltime\030\017 \001(\002\022\027\n\017weight_obst"
  "acle\030\020 \001(\002\022\030\n\020weight_inflation\030\021 \001(\002\022\037\n\027"
  "weight_dynamic_obstacle\030\022 \001(\002\022\027\n\017weight_"
  "viapoint\030\023 \001(\002\022\033\n\023weight_adapt_factor\030\024 "
  "\001(\002\022\034\n\024weight_prefer_rotdir\030\025 \001(\002\022\034\n\024wei"
  "ght_acc_lim_theta\030\026 \001(\002\"\201\005\n\024HomotopyClas"
  "sPlanner\022&\n\036enable_homotopy_class_planni"
  "ng\030\001 \001(\010\022\035\n\025enable_multithreading\030\002 \001(\010\022"
  "\032\n\022simple_exploration\030\003 \001(\010\022\032\n\022max_numbe"
  "r_classes\030\004 \001(\005\022!\n\031selection_obst_cost_s"
  "cale\030\005 \001(\002\022%\n\035selection_prefer_initial_p"
  "lan\030\006 \001(\002\022%\n\035selection_viapoint_cost_sca"
  "le\030\007 \001(\002\022!\n\031selection_cost_hysteresis\030\010 "
  "\001(\002\022\'\n\037selection_alternative_time_cost\030\t"
  " \001(\010\022 \n\030roadmap_graph_no_samples\030\n \001(\005\022 "
  "\n\030roadmap_graph_area_width\030\013 \001(\005\022\'\n\037road"
  "map_graph_area_length_scale\030\014 \001(\002\022\035\n\025h_s"
  "ignature_prescaler\030\r \001(\002\022\035\n\025h_signature_"
  "threshold\030\016 \001(\002\022 \n\030obstacle_keypoint_off"
  "set\030\017 \001(\002\022\"\n\032obstacle_heading_threshold\030"
  "\020 \001(\002\022 \n\030viapoints_all_candidates\030\021 \001(\010\022"
  "\032\n\022visualize_hc_graph\030\022 \001(\010\"\366\001\n\010Recovery"
  "\022#\n\033shrink_horizon_min_duration\030\001 \001(\010\022\034\n"
  "\024oscillation_recovery\030\002 \001(\010\022\035\n\025shrink_ho"
  "rizon_backup\030\003 \001(\010\022\031\n\021oscillation_v_eps\030"
  "\004 \001(\001\022\035\n\025oscillation_omega_eps\030\005 \001(\001\022)\n!"
  "oscillation_recovery_min_duration\030\006 \001(\001\022"
  "#\n\033oscillation_filter_duration\030\007 \001(\001\"\217\004\n"
  "\006Config\0221\n\topt_frame\030\001 \001(\0132\036.roborts_loc"
  "al_planner.FrameID\0229\n\016trajectory_opt\030\002 \001"
  "(\0132!.roborts_local_planner.Trajectory\0224\n"
  "\016kinematics_opt\030\003 \001(\0132\034.roborts_local_pl"
  "anner.Robot\022;\n\rtolerance_opt\030\004 \001(\0132$.rob"
  "orts_local_planner.GoalTolerance\0227\n\robst"
  "acles_opt\030\005 \001(\0132 .roborts_local_planner."
  "Obstacles\022:\n\roptimize_info\030\006 \001(\0132#.robor"
  "ts_local_planner.Optimization\022<\n\007hcp_opt"
  "\030\007 \001(\0132+.roborts_local_planner.HomotopyC"
  "lassPlanner\0229\n\nrobot_type\030\010 \003(\0132%.robort"
  "s_local_planner.FootprintModel\0226\n\rrecove"
  "ry_info\030\t \001(\0132\037.roborts_local_planner.Re"
  "covery"
  ;
static ::_pbi::once_flag descriptor_table_timed_5felastic_5fband_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_timed_5felastic_5fband_2eproto = {
    false, false, 3726, descriptor_table_protodef_timed_5felastic_5fband_2eproto,
    "timed_elastic_band.proto",
    &descriptor_table_timed_5felastic_5fband_2eproto_once, nullptr, 0, 11,
    schemas, file_default_instances, TableStruct_timed_5felastic_5fband_2eproto::offsets,
    file_level_metadata_timed_5felastic_5fband_2eproto, file_level_enum_descriptors_timed_5felastic_5fband_2eproto,
    file_level_service_descriptors_timed_5felastic_5fband_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_timed_5felastic_5fband_2eproto_getter() {
  return &descriptor_table_timed_5felastic_5fband_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_timed_5felastic_5fband_2eproto(&descriptor_table_timed_5felastic_5fband_2eproto);
namespace roborts_local_planner {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootprintModel_FootprintType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_timed_5felastic_5fband_2eproto);
  return file_level_enum_descriptors_timed_5felastic_5fband_2eproto[0];
}
bool FootprintModel_FootprintType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FootprintModel_FootprintType FootprintModel::POINT;
constexpr FootprintModel_FootprintType FootprintModel::CIRCULAR;
constexpr FootprintModel_FootprintType FootprintModel::TWOCIRCLES;
constexpr FootprintModel_FootprintType FootprintModel::LINE;
constexpr FootprintModel_FootprintType FootprintModel::POLYGON;
constexpr FootprintModel_FootprintType FootprintModel::FootprintType_MIN;
constexpr FootprintModel_FootprintType FootprintModel::FootprintType_MAX;
constexpr int FootprintModel::FootprintType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class FrameID::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameID>()._impl_._has_bits_);
  static void set_has_odom_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_map_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FrameID::FrameID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.FrameID)
}
FrameID::FrameID(const FrameID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.odom_frame_){}
    , decltype(_impl_.map_frame_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.odom_frame_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.odom_frame_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_odom_frame()) {
    _this->_impl_.odom_frame_.Set(from._internal_odom_frame(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_frame_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_frame_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_map_frame()) {
    _this->_impl_.map_frame_.Set(from._internal_map_frame(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.FrameID)
}

inline void FrameID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.odom_frame_){}
    , decltype(_impl_.map_frame_){}
  };
  _impl_.odom_frame_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.odom_frame_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_frame_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_frame_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameID::~FrameID() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.FrameID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.odom_frame_.Destroy();
  _impl_.map_frame_.Destroy();
}

void FrameID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameID::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.FrameID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.odom_frame_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.map_frame_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string odom_frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_odom_frame();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "roborts_local_planner.FrameID.odom_frame");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string map_frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_map_frame();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "roborts_local_planner.FrameID.map_frame");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.FrameID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string odom_frame = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_odom_frame().data(), static_cast<int>(this->_internal_odom_frame().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.odom_frame");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_odom_frame(), target);
  }

  // optional string map_frame = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_map_frame().data(), static_cast<int>(this->_internal_map_frame().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.map_frame");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_map_frame(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.FrameID)
  return target;
}

size_t FrameID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.FrameID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string odom_frame = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_odom_frame());
    }

    // optional string map_frame = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_map_frame());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameID::GetClassData() const { return &_class_data_; }


void FrameID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameID*>(&to_msg);
  auto& from = static_cast<const FrameID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.FrameID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_odom_frame(from._internal_odom_frame());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_map_frame(from._internal_map_frame());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameID::CopyFrom(const FrameID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.FrameID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameID::IsInitialized() const {
  return true;
}

void FrameID::InternalSwap(FrameID* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.odom_frame_, lhs_arena,
      &other->_impl_.odom_frame_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_frame_, lhs_arena,
      &other->_impl_.map_frame_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[0]);
}

// ===================================================================

class Point2D::_Internal {
 public:
  using HasBits = decltype(std::declval<Point2D>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Point2D::Point2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Point2D)
}
Point2D::Point2D(const Point2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Point2D* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Point2D)
}

inline void Point2D::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

Point2D::~Point2D() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Point2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Point2D::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Point2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Point2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Point2D)
  return target;
}

size_t Point2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Point2D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Point2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point2D::GetClassData() const { return &_class_data_; }


void Point2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Point2D*>(&to_msg);
  auto& from = static_cast<const Point2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Point2D)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point2D::CopyFrom(const Point2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Point2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point2D::IsInitialized() const {
  return true;
}

void Point2D::InternalSwap(Point2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point2D, _impl_.y_)
      + sizeof(Point2D::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Point2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[1]);
}

// ===================================================================

class Trajectory::_Internal {
 public:
  using HasBits = decltype(std::declval<Trajectory>()._impl_._has_bits_);
  static void set_has_teb_autosize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dt_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dt_hysteresis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_global_plan_overwrite_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_allow_init_with_backwards_motion(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_global_plan_viapoint_sep(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_via_points_ordered(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_global_plan_lookahead_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_exact_arc_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_force_reinit_new_goal_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_feasibility_check_no_poses(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_publish_feedback(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_min_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_max_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

Trajectory::Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Trajectory)
}
Trajectory::Trajectory(const Trajectory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Trajectory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dt_ref_){}
    , decltype(_impl_.dt_hysteresis_){}
    , decltype(_impl_.teb_autosize_){}
    , decltype(_impl_.global_plan_overwrite_orientation_){}
    , decltype(_impl_.allow_init_with_backwards_motion_){}
    , decltype(_impl_.via_points_ordered_){}
    , decltype(_impl_.global_plan_viapoint_sep_){}
    , decltype(_impl_.max_global_plan_lookahead_dist_){}
    , decltype(_impl_.force_reinit_new_goal_dist_){}
    , decltype(_impl_.feasibility_check_no_poses_){}
    , decltype(_impl_.min_samples_){}
    , decltype(_impl_.max_samples_){}
    , decltype(_impl_.exact_arc_length_){}
    , decltype(_impl_.publish_feedback_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dt_ref_, &from._impl_.dt_ref_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.publish_feedback_) -
    reinterpret_cast<char*>(&_impl_.dt_ref_)) + sizeof(_impl_.publish_feedback_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Trajectory)
}

inline void Trajectory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dt_ref_){0}
    , decltype(_impl_.dt_hysteresis_){0}
    , decltype(_impl_.teb_autosize_){false}
    , decltype(_impl_.global_plan_overwrite_orientation_){false}
    , decltype(_impl_.allow_init_with_backwards_motion_){false}
    , decltype(_impl_.via_points_ordered_){false}
    , decltype(_impl_.global_plan_viapoint_sep_){0}
    , decltype(_impl_.max_global_plan_lookahead_dist_){0}
    , decltype(_impl_.force_reinit_new_goal_dist_){0}
    , decltype(_impl_.feasibility_check_no_poses_){int64_t{0}}
    , decltype(_impl_.min_samples_){int64_t{0}}
    , decltype(_impl_.max_samples_){int64_t{0}}
    , decltype(_impl_.exact_arc_length_){false}
    , decltype(_impl_.publish_feedback_){false}
  };
}

Trajectory::~Trajectory() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Trajectory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trajectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Trajectory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Trajectory::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Trajectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dt_ref_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_global_plan_lookahead_dist_) -
        reinterpret_cast<char*>(&_impl_.dt_ref_)) + sizeof(_impl_.max_global_plan_lookahead_dist_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.force_reinit_new_goal_dist_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.publish_feedback_) -
        reinterpret_cast<char*>(&_impl_.force_reinit_new_goal_dist_)) + sizeof(_impl_.publish_feedback_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Trajectory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool teb_autosize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_teb_autosize(&has_bits);
          _impl_.teb_autosize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float dt_ref = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_dt_ref(&has_bits);
          _impl_.dt_ref_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float dt_hysteresis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_dt_hysteresis(&has_bits);
          _impl_.dt_hysteresis_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool global_plan_overwrite_orientation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_global_plan_overwrite_orientation(&has_bits);
          _impl_.global_plan_overwrite_orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_init_with_backwards_motion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_allow_init_with_backwards_motion(&has_bits);
          _impl_.allow_init_with_backwards_motion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float global_plan_viapoint_sep = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_global_plan_viapoint_sep(&has_bits);
          _impl_.global_plan_viapoint_sep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool via_points_ordered = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_via_points_ordered(&has_bits);
          _impl_.via_points_ordered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float max_global_plan_lookahead_dist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_max_global_plan_lookahead_dist(&has_bits);
          _impl_.max_global_plan_lookahead_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool exact_arc_length = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_exact_arc_length(&has_bits);
          _impl_.exact_arc_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float force_reinit_new_goal_dist = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_force_reinit_new_goal_dist(&has_bits);
          _impl_.force_reinit_new_goal_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int64 feasibility_check_no_poses = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_feasibility_check_no_poses(&has_bits);
          _impl_.feasibility_check_no_poses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool publish_feedback = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_publish_feedback(&has_bits);
          _impl_.publish_feedback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 min_samples = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_min_samples(&has_bits);
          _impl_.min_samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_samples = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_max_samples(&has_bits);
          _impl_.max_samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trajectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Trajectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool teb_autosize = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_teb_autosize(), target);
  }

  // optional float dt_ref = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_dt_ref(), target);
  }

  // optional float dt_hysteresis = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_dt_hysteresis(), target);
  }

  // optional bool global_plan_overwrite_orientation = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_global_plan_overwrite_orientation(), target);
  }

  // optional bool allow_init_with_backwards_motion = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_allow_init_with_backwards_motion(), target);
  }

  // optional float global_plan_viapoint_sep = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_global_plan_viapoint_sep(), target);
  }

  // optional bool via_points_ordered = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_via_points_ordered(), target);
  }

  // optional float max_global_plan_lookahead_dist = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_max_global_plan_lookahead_dist(), target);
  }

  // optional bool exact_arc_length = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_exact_arc_length(), target);
  }

  // optional float force_reinit_new_goal_dist = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_force_reinit_new_goal_dist(), target);
  }

  // optional int64 feasibility_check_no_poses = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_feasibility_check_no_poses(), target);
  }

  // optional bool publish_feedback = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_publish_feedback(), target);
  }

  // optional int64 min_samples = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_min_samples(), target);
  }

  // optional int64 max_samples = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_max_samples(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Trajectory)
  return target;
}

size_t Trajectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Trajectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float dt_ref = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float dt_hysteresis = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool teb_autosize = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool global_plan_overwrite_orientation = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool allow_init_with_backwards_motion = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool via_points_ordered = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional float global_plan_viapoint_sep = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float max_global_plan_lookahead_dist = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional float force_reinit_new_goal_dist = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional int64 feasibility_check_no_poses = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_feasibility_check_no_poses());
    }

    // optional int64 min_samples = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_samples());
    }

    // optional int64 max_samples = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_samples());
    }

    // optional bool exact_arc_length = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool publish_feedback = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Trajectory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Trajectory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Trajectory::GetClassData() const { return &_class_data_; }


void Trajectory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Trajectory*>(&to_msg);
  auto& from = static_cast<const Trajectory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Trajectory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dt_ref_ = from._impl_.dt_ref_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dt_hysteresis_ = from._impl_.dt_hysteresis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.teb_autosize_ = from._impl_.teb_autosize_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.global_plan_overwrite_orientation_ = from._impl_.global_plan_overwrite_orientation_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.allow_init_with_backwards_motion_ = from._impl_.allow_init_with_backwards_motion_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.via_points_ordered_ = from._impl_.via_points_ordered_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.global_plan_viapoint_sep_ = from._impl_.global_plan_viapoint_sep_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.max_global_plan_lookahead_dist_ = from._impl_.max_global_plan_lookahead_dist_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.force_reinit_new_goal_dist_ = from._impl_.force_reinit_new_goal_dist_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.feasibility_check_no_poses_ = from._impl_.feasibility_check_no_poses_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.min_samples_ = from._impl_.min_samples_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.max_samples_ = from._impl_.max_samples_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.exact_arc_length_ = from._impl_.exact_arc_length_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.publish_feedback_ = from._impl_.publish_feedback_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Trajectory::CopyFrom(const Trajectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Trajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trajectory::IsInitialized() const {
  return true;
}

void Trajectory::InternalSwap(Trajectory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Trajectory, _impl_.publish_feedback_)
      + sizeof(Trajectory::_impl_.publish_feedback_)
      - PROTOBUF_FIELD_OFFSET(Trajectory, _impl_.dt_ref_)>(
          reinterpret_cast<char*>(&_impl_.dt_ref_),
          reinterpret_cast<char*>(&other->_impl_.dt_ref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Trajectory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[2]);
}

// ===================================================================

class FootprintModel::_Internal {
 public:
  using HasBits = decltype(std::declval<FootprintModel>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_front_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_front_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rear_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rear_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

FootprintModel::FootprintModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.FootprintModel)
}
FootprintModel::FootprintModel(const FootprintModel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FootprintModel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_vertices_){from._impl_.robot_vertices_}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.front_offset_){}
    , decltype(_impl_.front_radius_){}
    , decltype(_impl_.rear_offset_){}
    , decltype(_impl_.rear_radius_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.radius_, &from._impl_.radius_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.radius_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.FootprintModel)
}

inline void FootprintModel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_vertices_){arena}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.front_offset_){0}
    , decltype(_impl_.front_radius_){0}
    , decltype(_impl_.rear_offset_){0}
    , decltype(_impl_.rear_radius_){0}
    , decltype(_impl_.type_){0}
  };
}

FootprintModel::~FootprintModel() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.FootprintModel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FootprintModel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.robot_vertices_.~RepeatedPtrField();
}

void FootprintModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FootprintModel::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.FootprintModel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.robot_vertices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.radius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.radius_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FootprintModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::roborts_local_planner::FootprintModel_FootprintType_IsValid(val))) {
            _internal_set_type(static_cast<::roborts_local_planner::FootprintModel_FootprintType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double front_offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_front_offset(&has_bits);
          _impl_.front_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double front_radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_front_radius(&has_bits);
          _impl_.front_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rear_offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_rear_offset(&has_bits);
          _impl_.rear_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rear_radius = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_rear_radius(&has_bits);
          _impl_.rear_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_local_planner.Point2D robot_vertices = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FootprintModel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.FootprintModel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional double radius = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_radius(), target);
  }

  // optional double front_offset = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_front_offset(), target);
  }

  // optional double front_radius = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_front_radius(), target);
  }

  // optional double rear_offset = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_rear_offset(), target);
  }

  // optional double rear_radius = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_rear_radius(), target);
  }

  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_robot_vertices_size()); i < n; i++) {
    const auto& repfield = this->_internal_robot_vertices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.FootprintModel)
  return target;
}

size_t FootprintModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.FootprintModel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  total_size += 1UL * this->_internal_robot_vertices_size();
  for (const auto& msg : this->_impl_.robot_vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional double radius = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double front_offset = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double front_radius = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double rear_offset = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double rear_radius = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FootprintModel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FootprintModel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FootprintModel::GetClassData() const { return &_class_data_; }


void FootprintModel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FootprintModel*>(&to_msg);
  auto& from = static_cast<const FootprintModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.FootprintModel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.robot_vertices_.MergeFrom(from._impl_.robot_vertices_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.front_offset_ = from._impl_.front_offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.front_radius_ = from._impl_.front_radius_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rear_offset_ = from._impl_.rear_offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rear_radius_ = from._impl_.rear_radius_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FootprintModel::CopyFrom(const FootprintModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.FootprintModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FootprintModel::IsInitialized() const {
  return true;
}

void FootprintModel::InternalSwap(FootprintModel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.robot_vertices_.InternalSwap(&other->_impl_.robot_vertices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FootprintModel, _impl_.type_)
      + sizeof(FootprintModel::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(FootprintModel, _impl_.radius_)>(
          reinterpret_cast<char*>(&_impl_.radius_),
          reinterpret_cast<char*>(&other->_impl_.radius_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FootprintModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[3]);
}

// ===================================================================

class Robot::_Internal {
 public:
  using HasBits = decltype(std::declval<Robot>()._impl_._has_bits_);
  static void set_has_max_vel_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_vel_x_backwards(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_vel_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_vel_theta(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_acc_lim_x(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_acc_lim_y(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_acc_lim_theta(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_min_turning_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_wheelbase(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_cmd_angle_instead_rotvel(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Robot::Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Robot)
}
Robot::Robot(const Robot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Robot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_vel_x_){}
    , decltype(_impl_.max_vel_x_backwards_){}
    , decltype(_impl_.max_vel_y_){}
    , decltype(_impl_.max_vel_theta_){}
    , decltype(_impl_.acc_lim_x_){}
    , decltype(_impl_.acc_lim_y_){}
    , decltype(_impl_.acc_lim_theta_){}
    , decltype(_impl_.min_turning_radius_){}
    , decltype(_impl_.wheelbase_){}
    , decltype(_impl_.cmd_angle_instead_rotvel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_vel_x_, &from._impl_.max_vel_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cmd_angle_instead_rotvel_) -
    reinterpret_cast<char*>(&_impl_.max_vel_x_)) + sizeof(_impl_.cmd_angle_instead_rotvel_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Robot)
}

inline void Robot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_vel_x_){0}
    , decltype(_impl_.max_vel_x_backwards_){0}
    , decltype(_impl_.max_vel_y_){0}
    , decltype(_impl_.max_vel_theta_){0}
    , decltype(_impl_.acc_lim_x_){0}
    , decltype(_impl_.acc_lim_y_){0}
    , decltype(_impl_.acc_lim_theta_){0}
    , decltype(_impl_.min_turning_radius_){0}
    , decltype(_impl_.wheelbase_){0}
    , decltype(_impl_.cmd_angle_instead_rotvel_){false}
  };
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Robot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Robot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Robot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Robot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.max_vel_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.min_turning_radius_) -
        reinterpret_cast<char*>(&_impl_.max_vel_x_)) + sizeof(_impl_.min_turning_radius_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.wheelbase_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cmd_angle_instead_rotvel_) -
        reinterpret_cast<char*>(&_impl_.wheelbase_)) + sizeof(_impl_.cmd_angle_instead_rotvel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Robot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float max_vel_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_max_vel_x(&has_bits);
          _impl_.max_vel_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_vel_x_backwards = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_max_vel_x_backwards(&has_bits);
          _impl_.max_vel_x_backwards_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_vel_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_max_vel_y(&has_bits);
          _impl_.max_vel_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_vel_theta = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_max_vel_theta(&has_bits);
          _impl_.max_vel_theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_lim_x = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_acc_lim_x(&has_bits);
          _impl_.acc_lim_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_lim_y = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_acc_lim_y(&has_bits);
          _impl_.acc_lim_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float acc_lim_theta = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_acc_lim_theta(&has_bits);
          _impl_.acc_lim_theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float min_turning_radius = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_min_turning_radius(&has_bits);
          _impl_.min_turning_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float wheelbase = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_wheelbase(&has_bits);
          _impl_.wheelbase_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool cmd_angle_instead_rotvel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_cmd_angle_instead_rotvel(&has_bits);
          _impl_.cmd_angle_instead_rotvel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Robot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Robot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float max_vel_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_max_vel_x(), target);
  }

  // optional float max_vel_x_backwards = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_max_vel_x_backwards(), target);
  }

  // optional float max_vel_y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_max_vel_y(), target);
  }

  // optional float max_vel_theta = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_max_vel_theta(), target);
  }

  // optional float acc_lim_x = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_acc_lim_x(), target);
  }

  // optional float acc_lim_y = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_acc_lim_y(), target);
  }

  // optional float acc_lim_theta = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_acc_lim_theta(), target);
  }

  // optional float min_turning_radius = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_min_turning_radius(), target);
  }

  // optional float wheelbase = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_wheelbase(), target);
  }

  // optional bool cmd_angle_instead_rotvel = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_cmd_angle_instead_rotvel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Robot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float max_vel_x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float max_vel_x_backwards = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float max_vel_y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float max_vel_theta = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_x = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_y = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_theta = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float min_turning_radius = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float wheelbase = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool cmd_angle_instead_rotvel = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Robot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Robot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Robot::GetClassData() const { return &_class_data_; }


void Robot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Robot*>(&to_msg);
  auto& from = static_cast<const Robot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Robot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.max_vel_x_ = from._impl_.max_vel_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.max_vel_x_backwards_ = from._impl_.max_vel_x_backwards_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_vel_y_ = from._impl_.max_vel_y_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_vel_theta_ = from._impl_.max_vel_theta_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.acc_lim_x_ = from._impl_.acc_lim_x_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.acc_lim_y_ = from._impl_.acc_lim_y_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.acc_lim_theta_ = from._impl_.acc_lim_theta_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.min_turning_radius_ = from._impl_.min_turning_radius_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.wheelbase_ = from._impl_.wheelbase_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.cmd_angle_instead_rotvel_ = from._impl_.cmd_angle_instead_rotvel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::InternalSwap(Robot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Robot, _impl_.cmd_angle_instead_rotvel_)
      + sizeof(Robot::_impl_.cmd_angle_instead_rotvel_)
      - PROTOBUF_FIELD_OFFSET(Robot, _impl_.max_vel_x_)>(
          reinterpret_cast<char*>(&_impl_.max_vel_x_),
          reinterpret_cast<char*>(&other->_impl_.max_vel_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Robot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[4]);
}

// ===================================================================

class GoalTolerance::_Internal {
 public:
  using HasBits = decltype(std::declval<GoalTolerance>()._impl_._has_bits_);
  static void set_has_xy_goal_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_yaw_goal_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_free_goal_vel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GoalTolerance::GoalTolerance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.GoalTolerance)
}
GoalTolerance::GoalTolerance(const GoalTolerance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GoalTolerance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.xy_goal_tolerance_){}
    , decltype(_impl_.yaw_goal_tolerance_){}
    , decltype(_impl_.free_goal_vel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.xy_goal_tolerance_, &from._impl_.xy_goal_tolerance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.free_goal_vel_) -
    reinterpret_cast<char*>(&_impl_.xy_goal_tolerance_)) + sizeof(_impl_.free_goal_vel_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.GoalTolerance)
}

inline void GoalTolerance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.xy_goal_tolerance_){0}
    , decltype(_impl_.yaw_goal_tolerance_){0}
    , decltype(_impl_.free_goal_vel_){false}
  };
}

GoalTolerance::~GoalTolerance() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.GoalTolerance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GoalTolerance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GoalTolerance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GoalTolerance::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.GoalTolerance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.xy_goal_tolerance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_goal_vel_) -
        reinterpret_cast<char*>(&_impl_.xy_goal_tolerance_)) + sizeof(_impl_.free_goal_vel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GoalTolerance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float xy_goal_tolerance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_xy_goal_tolerance(&has_bits);
          _impl_.xy_goal_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw_goal_tolerance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_yaw_goal_tolerance(&has_bits);
          _impl_.yaw_goal_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool free_goal_vel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_free_goal_vel(&has_bits);
          _impl_.free_goal_vel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GoalTolerance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.GoalTolerance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float xy_goal_tolerance = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_xy_goal_tolerance(), target);
  }

  // optional float yaw_goal_tolerance = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_yaw_goal_tolerance(), target);
  }

  // optional bool free_goal_vel = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_free_goal_vel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.GoalTolerance)
  return target;
}

size_t GoalTolerance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.GoalTolerance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float xy_goal_tolerance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float yaw_goal_tolerance = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool free_goal_vel = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GoalTolerance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GoalTolerance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GoalTolerance::GetClassData() const { return &_class_data_; }


void GoalTolerance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GoalTolerance*>(&to_msg);
  auto& from = static_cast<const GoalTolerance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.GoalTolerance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.xy_goal_tolerance_ = from._impl_.xy_goal_tolerance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.yaw_goal_tolerance_ = from._impl_.yaw_goal_tolerance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.free_goal_vel_ = from._impl_.free_goal_vel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GoalTolerance::CopyFrom(const GoalTolerance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.GoalTolerance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalTolerance::IsInitialized() const {
  return true;
}

void GoalTolerance::InternalSwap(GoalTolerance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GoalTolerance, _impl_.free_goal_vel_)
      + sizeof(GoalTolerance::_impl_.free_goal_vel_)
      - PROTOBUF_FIELD_OFFSET(GoalTolerance, _impl_.xy_goal_tolerance_)>(
          reinterpret_cast<char*>(&_impl_.xy_goal_tolerance_),
          reinterpret_cast<char*>(&other->_impl_.xy_goal_tolerance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GoalTolerance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[5]);
}

// ===================================================================

class Obstacles::_Internal {
 public:
  using HasBits = decltype(std::declval<Obstacles>()._impl_._has_bits_);
  static void set_has_min_obstacle_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inflation_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_include_costmap_obstacles(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_costmap_obstacles_behind_robot_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_obstacle_poses_affected(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_legacy_obstacle_association(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_obstacle_association_cutoff_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_obstacle_association_force_inclusion_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_costmap_converter_plugin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_costmap_converter_spin_thread(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_costmap_converter_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Obstacles::Obstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Obstacles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.costmap_converter_plugin_){}
    , decltype(_impl_.min_obstacle_dist_){}
    , decltype(_impl_.inflation_dist_){}
    , decltype(_impl_.costmap_obstacles_behind_robot_dist_){}
    , decltype(_impl_.obstacle_poses_affected_){}
    , decltype(_impl_.include_costmap_obstacles_){}
    , decltype(_impl_.legacy_obstacle_association_){}
    , decltype(_impl_.costmap_converter_spin_thread_){}
    , decltype(_impl_.obstacle_association_cutoff_factor_){}
    , decltype(_impl_.obstacle_association_force_inclusion_factor_){}
    , decltype(_impl_.costmap_converter_rate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.costmap_converter_plugin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.costmap_converter_plugin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_costmap_converter_plugin()) {
    _this->_impl_.costmap_converter_plugin_.Set(from._internal_costmap_converter_plugin(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_obstacle_dist_, &from._impl_.min_obstacle_dist_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.costmap_converter_rate_) -
    reinterpret_cast<char*>(&_impl_.min_obstacle_dist_)) + sizeof(_impl_.costmap_converter_rate_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Obstacles)
}

inline void Obstacles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.costmap_converter_plugin_){}
    , decltype(_impl_.min_obstacle_dist_){0}
    , decltype(_impl_.inflation_dist_){0}
    , decltype(_impl_.costmap_obstacles_behind_robot_dist_){0}
    , decltype(_impl_.obstacle_poses_affected_){0}
    , decltype(_impl_.include_costmap_obstacles_){false}
    , decltype(_impl_.legacy_obstacle_association_){false}
    , decltype(_impl_.costmap_converter_spin_thread_){false}
    , decltype(_impl_.obstacle_association_cutoff_factor_){0}
    , decltype(_impl_.obstacle_association_force_inclusion_factor_){0}
    , decltype(_impl_.costmap_converter_rate_){0}
  };
  _impl_.costmap_converter_plugin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.costmap_converter_plugin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Obstacles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Obstacles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.costmap_converter_plugin_.Destroy();
}

void Obstacles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Obstacles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.costmap_converter_plugin_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.min_obstacle_dist_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.costmap_converter_spin_thread_) -
        reinterpret_cast<char*>(&_impl_.min_obstacle_dist_)) + sizeof(_impl_.costmap_converter_spin_thread_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.obstacle_association_cutoff_factor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.costmap_converter_rate_) -
        reinterpret_cast<char*>(&_impl_.obstacle_association_cutoff_factor_)) + sizeof(_impl_.costmap_converter_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Obstacles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float min_obstacle_dist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_min_obstacle_dist(&has_bits);
          _impl_.min_obstacle_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float inflation_dist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_inflation_dist(&has_bits);
          _impl_.inflation_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_costmap_obstacles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_include_costmap_obstacles(&has_bits);
          _impl_.include_costmap_obstacles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float costmap_obstacles_behind_robot_dist = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_costmap_obstacles_behind_robot_dist(&has_bits);
          _impl_.costmap_obstacles_behind_robot_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float obstacle_poses_affected = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_obstacle_poses_affected(&has_bits);
          _impl_.obstacle_poses_affected_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool legacy_obstacle_association = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_legacy_obstacle_association(&has_bits);
          _impl_.legacy_obstacle_association_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float obstacle_association_cutoff_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_obstacle_association_cutoff_factor(&has_bits);
          _impl_.obstacle_association_cutoff_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float obstacle_association_force_inclusion_factor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_obstacle_association_force_inclusion_factor(&has_bits);
          _impl_.obstacle_association_force_inclusion_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string costmap_converter_plugin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_costmap_converter_plugin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "roborts_local_planner.Obstacles.costmap_converter_plugin");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool costmap_converter_spin_thread = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_costmap_converter_spin_thread(&has_bits);
          _impl_.costmap_converter_spin_thread_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float costmap_converter_rate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_costmap_converter_rate(&has_bits);
          _impl_.costmap_converter_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Obstacles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Obstacles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float min_obstacle_dist = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_min_obstacle_dist(), target);
  }

  // optional float inflation_dist = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_inflation_dist(), target);
  }

  // optional bool include_costmap_obstacles = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_include_costmap_obstacles(), target);
  }

  // optional float costmap_obstacles_behind_robot_dist = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_costmap_obstacles_behind_robot_dist(), target);
  }

  // optional float obstacle_poses_affected = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_obstacle_poses_affected(), target);
  }

  // optional bool legacy_obstacle_association = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_legacy_obstacle_association(), target);
  }

  // optional float obstacle_association_cutoff_factor = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_obstacle_association_cutoff_factor(), target);
  }

  // optional float obstacle_association_force_inclusion_factor = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_obstacle_association_force_inclusion_factor(), target);
  }

  // optional string costmap_converter_plugin = 9;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_costmap_converter_plugin().data(), static_cast<int>(this->_internal_costmap_converter_plugin().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.Obstacles.costmap_converter_plugin");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_costmap_converter_plugin(), target);
  }

  // optional bool costmap_converter_spin_thread = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_costmap_converter_spin_thread(), target);
  }

  // optional float costmap_converter_rate = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_costmap_converter_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Obstacles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string costmap_converter_plugin = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_costmap_converter_plugin());
    }

    // optional float min_obstacle_dist = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float inflation_dist = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float costmap_obstacles_behind_robot_dist = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float obstacle_poses_affected = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool include_costmap_obstacles = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool legacy_obstacle_association = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool costmap_converter_spin_thread = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float obstacle_association_cutoff_factor = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float obstacle_association_force_inclusion_factor = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float costmap_converter_rate = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Obstacles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Obstacles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Obstacles::GetClassData() const { return &_class_data_; }


void Obstacles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Obstacles*>(&to_msg);
  auto& from = static_cast<const Obstacles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Obstacles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_costmap_converter_plugin(from._internal_costmap_converter_plugin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.min_obstacle_dist_ = from._impl_.min_obstacle_dist_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.inflation_dist_ = from._impl_.inflation_dist_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.costmap_obstacles_behind_robot_dist_ = from._impl_.costmap_obstacles_behind_robot_dist_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.obstacle_poses_affected_ = from._impl_.obstacle_poses_affected_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.include_costmap_obstacles_ = from._impl_.include_costmap_obstacles_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.legacy_obstacle_association_ = from._impl_.legacy_obstacle_association_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.costmap_converter_spin_thread_ = from._impl_.costmap_converter_spin_thread_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.obstacle_association_cutoff_factor_ = from._impl_.obstacle_association_cutoff_factor_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.obstacle_association_force_inclusion_factor_ = from._impl_.obstacle_association_force_inclusion_factor_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.costmap_converter_rate_ = from._impl_.costmap_converter_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  return true;
}

void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.costmap_converter_plugin_, lhs_arena,
      &other->_impl_.costmap_converter_plugin_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Obstacles, _impl_.costmap_converter_rate_)
      + sizeof(Obstacles::_impl_.costmap_converter_rate_)
      - PROTOBUF_FIELD_OFFSET(Obstacles, _impl_.min_obstacle_dist_)>(
          reinterpret_cast<char*>(&_impl_.min_obstacle_dist_),
          reinterpret_cast<char*>(&other->_impl_.min_obstacle_dist_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Obstacles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[6]);
}

// ===================================================================

class Optimization::_Internal {
 public:
  using HasBits = decltype(std::declval<Optimization>()._impl_._has_bits_);
  static void set_has_no_inner_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_no_outer_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optimization_activate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_optimization_verbose(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_penalty_epsilon(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_weight_max_vel_x(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_weight_max_vel_y(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_weight_max_vel_theta(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_weight_acc_lim_x(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_weight_acc_lim_y(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_weight_acc_lim_thet(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_weight_kinematics_nh(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_weight_kinematics_forward_drive(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_weight_kinematics_turning_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_weight_optimaltime(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_weight_obstacle(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_weight_inflation(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_weight_dynamic_obstacle(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_weight_viapoint(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_weight_adapt_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_weight_prefer_rotdir(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_weight_acc_lim_theta(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

Optimization::Optimization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Optimization)
}
Optimization::Optimization(const Optimization& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Optimization* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.no_inner_iterations_){}
    , decltype(_impl_.no_outer_iterations_){}
    , decltype(_impl_.optimization_activate_){}
    , decltype(_impl_.optimization_verbose_){}
    , decltype(_impl_.penalty_epsilon_){}
    , decltype(_impl_.weight_max_vel_x_){}
    , decltype(_impl_.weight_max_vel_y_){}
    , decltype(_impl_.weight_max_vel_theta_){}
    , decltype(_impl_.weight_acc_lim_x_){}
    , decltype(_impl_.weight_acc_lim_y_){}
    , decltype(_impl_.weight_acc_lim_thet_){}
    , decltype(_impl_.weight_kinematics_nh_){}
    , decltype(_impl_.weight_kinematics_forward_drive_){}
    , decltype(_impl_.weight_kinematics_turning_radius_){}
    , decltype(_impl_.weight_optimaltime_){}
    , decltype(_impl_.weight_obstacle_){}
    , decltype(_impl_.weight_inflation_){}
    , decltype(_impl_.weight_dynamic_obstacle_){}
    , decltype(_impl_.weight_viapoint_){}
    , decltype(_impl_.weight_adapt_factor_){}
    , decltype(_impl_.weight_prefer_rotdir_){}
    , decltype(_impl_.weight_acc_lim_theta_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.no_inner_iterations_, &from._impl_.no_inner_iterations_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weight_acc_lim_theta_) -
    reinterpret_cast<char*>(&_impl_.no_inner_iterations_)) + sizeof(_impl_.weight_acc_lim_theta_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Optimization)
}

inline void Optimization::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.no_inner_iterations_){0}
    , decltype(_impl_.no_outer_iterations_){0}
    , decltype(_impl_.optimization_activate_){false}
    , decltype(_impl_.optimization_verbose_){false}
    , decltype(_impl_.penalty_epsilon_){0}
    , decltype(_impl_.weight_max_vel_x_){0}
    , decltype(_impl_.weight_max_vel_y_){0}
    , decltype(_impl_.weight_max_vel_theta_){0}
    , decltype(_impl_.weight_acc_lim_x_){0}
    , decltype(_impl_.weight_acc_lim_y_){0}
    , decltype(_impl_.weight_acc_lim_thet_){0}
    , decltype(_impl_.weight_kinematics_nh_){0}
    , decltype(_impl_.weight_kinematics_forward_drive_){0}
    , decltype(_impl_.weight_kinematics_turning_radius_){0}
    , decltype(_impl_.weight_optimaltime_){0}
    , decltype(_impl_.weight_obstacle_){0}
    , decltype(_impl_.weight_inflation_){0}
    , decltype(_impl_.weight_dynamic_obstacle_){0}
    , decltype(_impl_.weight_viapoint_){0}
    , decltype(_impl_.weight_adapt_factor_){0}
    , decltype(_impl_.weight_prefer_rotdir_){0}
    , decltype(_impl_.weight_acc_lim_theta_){0}
  };
}

Optimization::~Optimization() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Optimization)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optimization::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optimization::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optimization::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Optimization)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.no_inner_iterations_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weight_max_vel_theta_) -
        reinterpret_cast<char*>(&_impl_.no_inner_iterations_)) + sizeof(_impl_.weight_max_vel_theta_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.weight_acc_lim_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weight_obstacle_) -
        reinterpret_cast<char*>(&_impl_.weight_acc_lim_x_)) + sizeof(_impl_.weight_obstacle_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.weight_inflation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weight_acc_lim_theta_) -
        reinterpret_cast<char*>(&_impl_.weight_inflation_)) + sizeof(_impl_.weight_acc_lim_theta_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optimization::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 no_inner_iterations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_no_inner_iterations(&has_bits);
          _impl_.no_inner_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 no_outer_iterations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_no_outer_iterations(&has_bits);
          _impl_.no_outer_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optimization_activate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_optimization_activate(&has_bits);
          _impl_.optimization_activate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optimization_verbose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_optimization_verbose(&has_bits);
          _impl_.optimization_verbose_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float penalty_epsilon = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_penalty_epsilon(&has_bits);
          _impl_.penalty_epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_max_vel_x = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_weight_max_vel_x(&has_bits);
          _impl_.weight_max_vel_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_max_vel_y = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_weight_max_vel_y(&has_bits);
          _impl_.weight_max_vel_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_max_vel_theta = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_weight_max_vel_theta(&has_bits);
          _impl_.weight_max_vel_theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_acc_lim_x = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_weight_acc_lim_x(&has_bits);
          _impl_.weight_acc_lim_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_acc_lim_y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_weight_acc_lim_y(&has_bits);
          _impl_.weight_acc_lim_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_acc_lim_thet = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_weight_acc_lim_thet(&has_bits);
          _impl_.weight_acc_lim_thet_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_kinematics_nh = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_weight_kinematics_nh(&has_bits);
          _impl_.weight_kinematics_nh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_kinematics_forward_drive = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_weight_kinematics_forward_drive(&has_bits);
          _impl_.weight_kinematics_forward_drive_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_kinematics_turning_radius = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_weight_kinematics_turning_radius(&has_bits);
          _impl_.weight_kinematics_turning_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_optimaltime = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_weight_optimaltime(&has_bits);
          _impl_.weight_optimaltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_obstacle = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_weight_obstacle(&has_bits);
          _impl_.weight_obstacle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_inflation = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_weight_inflation(&has_bits);
          _impl_.weight_inflation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_dynamic_obstacle = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_weight_dynamic_obstacle(&has_bits);
          _impl_.weight_dynamic_obstacle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_viapoint = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_weight_viapoint(&has_bits);
          _impl_.weight_viapoint_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_adapt_factor = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _Internal::set_has_weight_adapt_factor(&has_bits);
          _impl_.weight_adapt_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_prefer_rotdir = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_weight_prefer_rotdir(&has_bits);
          _impl_.weight_prefer_rotdir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float weight_acc_lim_theta = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_weight_acc_lim_theta(&has_bits);
          _impl_.weight_acc_lim_theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Optimization::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Optimization)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 no_inner_iterations = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_no_inner_iterations(), target);
  }

  // optional int32 no_outer_iterations = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_no_outer_iterations(), target);
  }

  // optional bool optimization_activate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_optimization_activate(), target);
  }

  // optional bool optimization_verbose = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_optimization_verbose(), target);
  }

  // optional float penalty_epsilon = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_penalty_epsilon(), target);
  }

  // optional float weight_max_vel_x = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_weight_max_vel_x(), target);
  }

  // optional float weight_max_vel_y = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_weight_max_vel_y(), target);
  }

  // optional float weight_max_vel_theta = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_weight_max_vel_theta(), target);
  }

  // optional float weight_acc_lim_x = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_weight_acc_lim_x(), target);
  }

  // optional float weight_acc_lim_y = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_weight_acc_lim_y(), target);
  }

  // optional float weight_acc_lim_thet = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_weight_acc_lim_thet(), target);
  }

  // optional float weight_kinematics_nh = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_weight_kinematics_nh(), target);
  }

  // optional float weight_kinematics_forward_drive = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_weight_kinematics_forward_drive(), target);
  }

  // optional float weight_kinematics_turning_radius = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_weight_kinematics_turning_radius(), target);
  }

  // optional float weight_optimaltime = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_weight_optimaltime(), target);
  }

  // optional float weight_obstacle = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_weight_obstacle(), target);
  }

  // optional float weight_inflation = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_weight_inflation(), target);
  }

  // optional float weight_dynamic_obstacle = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_weight_dynamic_obstacle(), target);
  }

  // optional float weight_viapoint = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_weight_viapoint(), target);
  }

  // optional float weight_adapt_factor = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_weight_adapt_factor(), target);
  }

  // optional float weight_prefer_rotdir = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_weight_prefer_rotdir(), target);
  }

  // optional float weight_acc_lim_theta = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_weight_acc_lim_theta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Optimization)
  return target;
}

size_t Optimization::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Optimization)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 no_inner_iterations = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_no_inner_iterations());
    }

    // optional int32 no_outer_iterations = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_no_outer_iterations());
    }

    // optional bool optimization_activate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool optimization_verbose = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional float penalty_epsilon = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_x = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_y = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_theta = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float weight_acc_lim_x = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float weight_acc_lim_y = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float weight_acc_lim_thet = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_nh = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_forward_drive = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_turning_radius = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float weight_optimaltime = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float weight_obstacle = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional float weight_inflation = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float weight_dynamic_obstacle = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional float weight_viapoint = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional float weight_adapt_factor = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float weight_prefer_rotdir = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional float weight_acc_lim_theta = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optimization::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optimization::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optimization::GetClassData() const { return &_class_data_; }


void Optimization::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optimization*>(&to_msg);
  auto& from = static_cast<const Optimization&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Optimization)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.no_inner_iterations_ = from._impl_.no_inner_iterations_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.no_outer_iterations_ = from._impl_.no_outer_iterations_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optimization_activate_ = from._impl_.optimization_activate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.optimization_verbose_ = from._impl_.optimization_verbose_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.penalty_epsilon_ = from._impl_.penalty_epsilon_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.weight_max_vel_x_ = from._impl_.weight_max_vel_x_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.weight_max_vel_y_ = from._impl_.weight_max_vel_y_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.weight_max_vel_theta_ = from._impl_.weight_max_vel_theta_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.weight_acc_lim_x_ = from._impl_.weight_acc_lim_x_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.weight_acc_lim_y_ = from._impl_.weight_acc_lim_y_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.weight_acc_lim_thet_ = from._impl_.weight_acc_lim_thet_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.weight_kinematics_nh_ = from._impl_.weight_kinematics_nh_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.weight_kinematics_forward_drive_ = from._impl_.weight_kinematics_forward_drive_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.weight_kinematics_turning_radius_ = from._impl_.weight_kinematics_turning_radius_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.weight_optimaltime_ = from._impl_.weight_optimaltime_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.weight_obstacle_ = from._impl_.weight_obstacle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.weight_inflation_ = from._impl_.weight_inflation_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.weight_dynamic_obstacle_ = from._impl_.weight_dynamic_obstacle_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.weight_viapoint_ = from._impl_.weight_viapoint_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.weight_adapt_factor_ = from._impl_.weight_adapt_factor_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.weight_prefer_rotdir_ = from._impl_.weight_prefer_rotdir_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.weight_acc_lim_theta_ = from._impl_.weight_acc_lim_theta_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optimization::CopyFrom(const Optimization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Optimization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optimization::IsInitialized() const {
  return true;
}

void Optimization::InternalSwap(Optimization* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Optimization, _impl_.weight_acc_lim_theta_)
      + sizeof(Optimization::_impl_.weight_acc_lim_theta_)
      - PROTOBUF_FIELD_OFFSET(Optimization, _impl_.no_inner_iterations_)>(
          reinterpret_cast<char*>(&_impl_.no_inner_iterations_),
          reinterpret_cast<char*>(&other->_impl_.no_inner_iterations_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Optimization::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[7]);
}

// ===================================================================

class HomotopyClassPlanner::_Internal {
 public:
  using HasBits = decltype(std::declval<HomotopyClassPlanner>()._impl_._has_bits_);
  static void set_has_enable_homotopy_class_planning(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_multithreading(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_simple_exploration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_number_classes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_obst_cost_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_selection_prefer_initial_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_selection_viapoint_cost_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_selection_cost_hysteresis(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_selection_alternative_time_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_roadmap_graph_no_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_roadmap_graph_area_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_roadmap_graph_area_length_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_h_signature_prescaler(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_h_signature_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_obstacle_keypoint_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_obstacle_heading_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_viapoints_all_candidates(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_visualize_hc_graph(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

HomotopyClassPlanner::HomotopyClassPlanner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.HomotopyClassPlanner)
}
HomotopyClassPlanner::HomotopyClassPlanner(const HomotopyClassPlanner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HomotopyClassPlanner* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_homotopy_class_planning_){}
    , decltype(_impl_.enable_multithreading_){}
    , decltype(_impl_.simple_exploration_){}
    , decltype(_impl_.selection_alternative_time_cost_){}
    , decltype(_impl_.max_number_classes_){}
    , decltype(_impl_.selection_obst_cost_scale_){}
    , decltype(_impl_.selection_prefer_initial_plan_){}
    , decltype(_impl_.selection_viapoint_cost_scale_){}
    , decltype(_impl_.selection_cost_hysteresis_){}
    , decltype(_impl_.roadmap_graph_no_samples_){}
    , decltype(_impl_.roadmap_graph_area_width_){}
    , decltype(_impl_.roadmap_graph_area_length_scale_){}
    , decltype(_impl_.h_signature_prescaler_){}
    , decltype(_impl_.h_signature_threshold_){}
    , decltype(_impl_.obstacle_keypoint_offset_){}
    , decltype(_impl_.obstacle_heading_threshold_){}
    , decltype(_impl_.viapoints_all_candidates_){}
    , decltype(_impl_.visualize_hc_graph_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_homotopy_class_planning_, &from._impl_.enable_homotopy_class_planning_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.visualize_hc_graph_) -
    reinterpret_cast<char*>(&_impl_.enable_homotopy_class_planning_)) + sizeof(_impl_.visualize_hc_graph_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.HomotopyClassPlanner)
}

inline void HomotopyClassPlanner::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_homotopy_class_planning_){false}
    , decltype(_impl_.enable_multithreading_){false}
    , decltype(_impl_.simple_exploration_){false}
    , decltype(_impl_.selection_alternative_time_cost_){false}
    , decltype(_impl_.max_number_classes_){0}
    , decltype(_impl_.selection_obst_cost_scale_){0}
    , decltype(_impl_.selection_prefer_initial_plan_){0}
    , decltype(_impl_.selection_viapoint_cost_scale_){0}
    , decltype(_impl_.selection_cost_hysteresis_){0}
    , decltype(_impl_.roadmap_graph_no_samples_){0}
    , decltype(_impl_.roadmap_graph_area_width_){0}
    , decltype(_impl_.roadmap_graph_area_length_scale_){0}
    , decltype(_impl_.h_signature_prescaler_){0}
    , decltype(_impl_.h_signature_threshold_){0}
    , decltype(_impl_.obstacle_keypoint_offset_){0}
    , decltype(_impl_.obstacle_heading_threshold_){0}
    , decltype(_impl_.viapoints_all_candidates_){false}
    , decltype(_impl_.visualize_hc_graph_){false}
  };
}

HomotopyClassPlanner::~HomotopyClassPlanner() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.HomotopyClassPlanner)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HomotopyClassPlanner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HomotopyClassPlanner::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HomotopyClassPlanner::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.HomotopyClassPlanner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.enable_homotopy_class_planning_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_viapoint_cost_scale_) -
        reinterpret_cast<char*>(&_impl_.enable_homotopy_class_planning_)) + sizeof(_impl_.selection_viapoint_cost_scale_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.selection_cost_hysteresis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.obstacle_heading_threshold_) -
        reinterpret_cast<char*>(&_impl_.selection_cost_hysteresis_)) + sizeof(_impl_.obstacle_heading_threshold_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&_impl_.viapoints_all_candidates_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.visualize_hc_graph_) -
        reinterpret_cast<char*>(&_impl_.viapoints_all_candidates_)) + sizeof(_impl_.visualize_hc_graph_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HomotopyClassPlanner::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_homotopy_class_planning = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_homotopy_class_planning(&has_bits);
          _impl_.enable_homotopy_class_planning_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_multithreading = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enable_multithreading(&has_bits);
          _impl_.enable_multithreading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool simple_exploration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_simple_exploration(&has_bits);
          _impl_.simple_exploration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_number_classes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_number_classes(&has_bits);
          _impl_.max_number_classes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float selection_obst_cost_scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_selection_obst_cost_scale(&has_bits);
          _impl_.selection_obst_cost_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float selection_prefer_initial_plan = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_selection_prefer_initial_plan(&has_bits);
          _impl_.selection_prefer_initial_plan_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float selection_viapoint_cost_scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_selection_viapoint_cost_scale(&has_bits);
          _impl_.selection_viapoint_cost_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float selection_cost_hysteresis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_selection_cost_hysteresis(&has_bits);
          _impl_.selection_cost_hysteresis_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool selection_alternative_time_cost = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_selection_alternative_time_cost(&has_bits);
          _impl_.selection_alternative_time_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 roadmap_graph_no_samples = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_roadmap_graph_no_samples(&has_bits);
          _impl_.roadmap_graph_no_samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 roadmap_graph_area_width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_roadmap_graph_area_width(&has_bits);
          _impl_.roadmap_graph_area_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float roadmap_graph_area_length_scale = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_roadmap_graph_area_length_scale(&has_bits);
          _impl_.roadmap_graph_area_length_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float h_signature_prescaler = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_h_signature_prescaler(&has_bits);
          _impl_.h_signature_prescaler_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float h_signature_threshold = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_h_signature_threshold(&has_bits);
          _impl_.h_signature_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float obstacle_keypoint_offset = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_obstacle_keypoint_offset(&has_bits);
          _impl_.obstacle_keypoint_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float obstacle_heading_threshold = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_obstacle_heading_threshold(&has_bits);
          _impl_.obstacle_heading_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool viapoints_all_candidates = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_viapoints_all_candidates(&has_bits);
          _impl_.viapoints_all_candidates_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool visualize_hc_graph = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_visualize_hc_graph(&has_bits);
          _impl_.visualize_hc_graph_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HomotopyClassPlanner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.HomotopyClassPlanner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable_homotopy_class_planning = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_homotopy_class_planning(), target);
  }

  // optional bool enable_multithreading = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_multithreading(), target);
  }

  // optional bool simple_exploration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_simple_exploration(), target);
  }

  // optional int32 max_number_classes = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_number_classes(), target);
  }

  // optional float selection_obst_cost_scale = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_selection_obst_cost_scale(), target);
  }

  // optional float selection_prefer_initial_plan = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_selection_prefer_initial_plan(), target);
  }

  // optional float selection_viapoint_cost_scale = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_selection_viapoint_cost_scale(), target);
  }

  // optional float selection_cost_hysteresis = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_selection_cost_hysteresis(), target);
  }

  // optional bool selection_alternative_time_cost = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_selection_alternative_time_cost(), target);
  }

  // optional int32 roadmap_graph_no_samples = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_roadmap_graph_no_samples(), target);
  }

  // optional int32 roadmap_graph_area_width = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_roadmap_graph_area_width(), target);
  }

  // optional float roadmap_graph_area_length_scale = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_roadmap_graph_area_length_scale(), target);
  }

  // optional float h_signature_prescaler = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_h_signature_prescaler(), target);
  }

  // optional float h_signature_threshold = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_h_signature_threshold(), target);
  }

  // optional float obstacle_keypoint_offset = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_obstacle_keypoint_offset(), target);
  }

  // optional float obstacle_heading_threshold = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_obstacle_heading_threshold(), target);
  }

  // optional bool viapoints_all_candidates = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_viapoints_all_candidates(), target);
  }

  // optional bool visualize_hc_graph = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_visualize_hc_graph(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.HomotopyClassPlanner)
  return target;
}

size_t HomotopyClassPlanner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.HomotopyClassPlanner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool enable_homotopy_class_planning = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enable_multithreading = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool simple_exploration = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool selection_alternative_time_cost = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int32 max_number_classes = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_number_classes());
    }

    // optional float selection_obst_cost_scale = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float selection_prefer_initial_plan = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float selection_viapoint_cost_scale = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float selection_cost_hysteresis = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional int32 roadmap_graph_no_samples = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roadmap_graph_no_samples());
    }

    // optional int32 roadmap_graph_area_width = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roadmap_graph_area_width());
    }

    // optional float roadmap_graph_area_length_scale = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float h_signature_prescaler = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float h_signature_threshold = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float obstacle_keypoint_offset = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float obstacle_heading_threshold = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional bool viapoints_all_candidates = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool visualize_hc_graph = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HomotopyClassPlanner::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HomotopyClassPlanner::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HomotopyClassPlanner::GetClassData() const { return &_class_data_; }


void HomotopyClassPlanner::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HomotopyClassPlanner*>(&to_msg);
  auto& from = static_cast<const HomotopyClassPlanner&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.HomotopyClassPlanner)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.enable_homotopy_class_planning_ = from._impl_.enable_homotopy_class_planning_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enable_multithreading_ = from._impl_.enable_multithreading_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.simple_exploration_ = from._impl_.simple_exploration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_alternative_time_cost_ = from._impl_.selection_alternative_time_cost_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.max_number_classes_ = from._impl_.max_number_classes_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_obst_cost_scale_ = from._impl_.selection_obst_cost_scale_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.selection_prefer_initial_plan_ = from._impl_.selection_prefer_initial_plan_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.selection_viapoint_cost_scale_ = from._impl_.selection_viapoint_cost_scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.selection_cost_hysteresis_ = from._impl_.selection_cost_hysteresis_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.roadmap_graph_no_samples_ = from._impl_.roadmap_graph_no_samples_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.roadmap_graph_area_width_ = from._impl_.roadmap_graph_area_width_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.roadmap_graph_area_length_scale_ = from._impl_.roadmap_graph_area_length_scale_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.h_signature_prescaler_ = from._impl_.h_signature_prescaler_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.h_signature_threshold_ = from._impl_.h_signature_threshold_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.obstacle_keypoint_offset_ = from._impl_.obstacle_keypoint_offset_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.obstacle_heading_threshold_ = from._impl_.obstacle_heading_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.viapoints_all_candidates_ = from._impl_.viapoints_all_candidates_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.visualize_hc_graph_ = from._impl_.visualize_hc_graph_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HomotopyClassPlanner::CopyFrom(const HomotopyClassPlanner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.HomotopyClassPlanner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HomotopyClassPlanner::IsInitialized() const {
  return true;
}

void HomotopyClassPlanner::InternalSwap(HomotopyClassPlanner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HomotopyClassPlanner, _impl_.visualize_hc_graph_)
      + sizeof(HomotopyClassPlanner::_impl_.visualize_hc_graph_)
      - PROTOBUF_FIELD_OFFSET(HomotopyClassPlanner, _impl_.enable_homotopy_class_planning_)>(
          reinterpret_cast<char*>(&_impl_.enable_homotopy_class_planning_),
          reinterpret_cast<char*>(&other->_impl_.enable_homotopy_class_planning_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HomotopyClassPlanner::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[8]);
}

// ===================================================================

class Recovery::_Internal {
 public:
  using HasBits = decltype(std::declval<Recovery>()._impl_._has_bits_);
  static void set_has_shrink_horizon_min_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_oscillation_recovery(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shrink_horizon_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_oscillation_v_eps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_oscillation_omega_eps(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oscillation_recovery_min_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_oscillation_filter_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Recovery::Recovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Recovery)
}
Recovery::Recovery(const Recovery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Recovery* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oscillation_v_eps_){}
    , decltype(_impl_.oscillation_omega_eps_){}
    , decltype(_impl_.oscillation_recovery_min_duration_){}
    , decltype(_impl_.oscillation_filter_duration_){}
    , decltype(_impl_.shrink_horizon_min_duration_){}
    , decltype(_impl_.oscillation_recovery_){}
    , decltype(_impl_.shrink_horizon_backup_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.oscillation_v_eps_, &from._impl_.oscillation_v_eps_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shrink_horizon_backup_) -
    reinterpret_cast<char*>(&_impl_.oscillation_v_eps_)) + sizeof(_impl_.shrink_horizon_backup_));
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Recovery)
}

inline void Recovery::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oscillation_v_eps_){0}
    , decltype(_impl_.oscillation_omega_eps_){0}
    , decltype(_impl_.oscillation_recovery_min_duration_){0}
    , decltype(_impl_.oscillation_filter_duration_){0}
    , decltype(_impl_.shrink_horizon_min_duration_){false}
    , decltype(_impl_.oscillation_recovery_){false}
    , decltype(_impl_.shrink_horizon_backup_){false}
  };
}

Recovery::~Recovery() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Recovery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Recovery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Recovery::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Recovery::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Recovery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.oscillation_v_eps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shrink_horizon_backup_) -
        reinterpret_cast<char*>(&_impl_.oscillation_v_eps_)) + sizeof(_impl_.shrink_horizon_backup_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Recovery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool shrink_horizon_min_duration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shrink_horizon_min_duration(&has_bits);
          _impl_.shrink_horizon_min_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool oscillation_recovery = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_oscillation_recovery(&has_bits);
          _impl_.oscillation_recovery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shrink_horizon_backup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shrink_horizon_backup(&has_bits);
          _impl_.shrink_horizon_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double oscillation_v_eps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_oscillation_v_eps(&has_bits);
          _impl_.oscillation_v_eps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double oscillation_omega_eps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_oscillation_omega_eps(&has_bits);
          _impl_.oscillation_omega_eps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double oscillation_recovery_min_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_oscillation_recovery_min_duration(&has_bits);
          _impl_.oscillation_recovery_min_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double oscillation_filter_duration = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_oscillation_filter_duration(&has_bits);
          _impl_.oscillation_filter_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Recovery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Recovery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool shrink_horizon_min_duration = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_shrink_horizon_min_duration(), target);
  }

  // optional bool oscillation_recovery = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_oscillation_recovery(), target);
  }

  // optional bool shrink_horizon_backup = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_shrink_horizon_backup(), target);
  }

  // optional double oscillation_v_eps = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_oscillation_v_eps(), target);
  }

  // optional double oscillation_omega_eps = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_oscillation_omega_eps(), target);
  }

  // optional double oscillation_recovery_min_duration = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_oscillation_recovery_min_duration(), target);
  }

  // optional double oscillation_filter_duration = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_oscillation_filter_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Recovery)
  return target;
}

size_t Recovery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Recovery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional double oscillation_v_eps = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double oscillation_omega_eps = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double oscillation_recovery_min_duration = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double oscillation_filter_duration = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional bool shrink_horizon_min_duration = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool oscillation_recovery = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool shrink_horizon_backup = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Recovery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Recovery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Recovery::GetClassData() const { return &_class_data_; }


void Recovery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Recovery*>(&to_msg);
  auto& from = static_cast<const Recovery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Recovery)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.oscillation_v_eps_ = from._impl_.oscillation_v_eps_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.oscillation_omega_eps_ = from._impl_.oscillation_omega_eps_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.oscillation_recovery_min_duration_ = from._impl_.oscillation_recovery_min_duration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.oscillation_filter_duration_ = from._impl_.oscillation_filter_duration_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.shrink_horizon_min_duration_ = from._impl_.shrink_horizon_min_duration_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.oscillation_recovery_ = from._impl_.oscillation_recovery_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shrink_horizon_backup_ = from._impl_.shrink_horizon_backup_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Recovery::CopyFrom(const Recovery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Recovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Recovery::IsInitialized() const {
  return true;
}

void Recovery::InternalSwap(Recovery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Recovery, _impl_.shrink_horizon_backup_)
      + sizeof(Recovery::_impl_.shrink_horizon_backup_)
      - PROTOBUF_FIELD_OFFSET(Recovery, _impl_.oscillation_v_eps_)>(
          reinterpret_cast<char*>(&_impl_.oscillation_v_eps_),
          reinterpret_cast<char*>(&other->_impl_.oscillation_v_eps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Recovery::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[9]);
}

// ===================================================================

class Config::_Internal {
 public:
  using HasBits = decltype(std::declval<Config>()._impl_._has_bits_);
  static const ::roborts_local_planner::FrameID& opt_frame(const Config* msg);
  static void set_has_opt_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::roborts_local_planner::Trajectory& trajectory_opt(const Config* msg);
  static void set_has_trajectory_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::roborts_local_planner::Robot& kinematics_opt(const Config* msg);
  static void set_has_kinematics_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::roborts_local_planner::GoalTolerance& tolerance_opt(const Config* msg);
  static void set_has_tolerance_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::roborts_local_planner::Obstacles& obstacles_opt(const Config* msg);
  static void set_has_obstacles_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::roborts_local_planner::Optimization& optimize_info(const Config* msg);
  static void set_has_optimize_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::roborts_local_planner::HomotopyClassPlanner& hcp_opt(const Config* msg);
  static void set_has_hcp_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::roborts_local_planner::Recovery& recovery_info(const Config* msg);
  static void set_has_recovery_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::roborts_local_planner::FrameID&
Config::_Internal::opt_frame(const Config* msg) {
  return *msg->_impl_.opt_frame_;
}
const ::roborts_local_planner::Trajectory&
Config::_Internal::trajectory_opt(const Config* msg) {
  return *msg->_impl_.trajectory_opt_;
}
const ::roborts_local_planner::Robot&
Config::_Internal::kinematics_opt(const Config* msg) {
  return *msg->_impl_.kinematics_opt_;
}
const ::roborts_local_planner::GoalTolerance&
Config::_Internal::tolerance_opt(const Config* msg) {
  return *msg->_impl_.tolerance_opt_;
}
const ::roborts_local_planner::Obstacles&
Config::_Internal::obstacles_opt(const Config* msg) {
  return *msg->_impl_.obstacles_opt_;
}
const ::roborts_local_planner::Optimization&
Config::_Internal::optimize_info(const Config* msg) {
  return *msg->_impl_.optimize_info_;
}
const ::roborts_local_planner::HomotopyClassPlanner&
Config::_Internal::hcp_opt(const Config* msg) {
  return *msg->_impl_.hcp_opt_;
}
const ::roborts_local_planner::Recovery&
Config::_Internal::recovery_info(const Config* msg) {
  return *msg->_impl_.recovery_info_;
}
Config::Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_local_planner.Config)
}
Config::Config(const Config& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Config* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_type_){from._impl_.robot_type_}
    , decltype(_impl_.opt_frame_){nullptr}
    , decltype(_impl_.trajectory_opt_){nullptr}
    , decltype(_impl_.kinematics_opt_){nullptr}
    , decltype(_impl_.tolerance_opt_){nullptr}
    , decltype(_impl_.obstacles_opt_){nullptr}
    , decltype(_impl_.optimize_info_){nullptr}
    , decltype(_impl_.hcp_opt_){nullptr}
    , decltype(_impl_.recovery_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_opt_frame()) {
    _this->_impl_.opt_frame_ = new ::roborts_local_planner::FrameID(*from._impl_.opt_frame_);
  }
  if (from._internal_has_trajectory_opt()) {
    _this->_impl_.trajectory_opt_ = new ::roborts_local_planner::Trajectory(*from._impl_.trajectory_opt_);
  }
  if (from._internal_has_kinematics_opt()) {
    _this->_impl_.kinematics_opt_ = new ::roborts_local_planner::Robot(*from._impl_.kinematics_opt_);
  }
  if (from._internal_has_tolerance_opt()) {
    _this->_impl_.tolerance_opt_ = new ::roborts_local_planner::GoalTolerance(*from._impl_.tolerance_opt_);
  }
  if (from._internal_has_obstacles_opt()) {
    _this->_impl_.obstacles_opt_ = new ::roborts_local_planner::Obstacles(*from._impl_.obstacles_opt_);
  }
  if (from._internal_has_optimize_info()) {
    _this->_impl_.optimize_info_ = new ::roborts_local_planner::Optimization(*from._impl_.optimize_info_);
  }
  if (from._internal_has_hcp_opt()) {
    _this->_impl_.hcp_opt_ = new ::roborts_local_planner::HomotopyClassPlanner(*from._impl_.hcp_opt_);
  }
  if (from._internal_has_recovery_info()) {
    _this->_impl_.recovery_info_ = new ::roborts_local_planner::Recovery(*from._impl_.recovery_info_);
  }
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Config)
}

inline void Config::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robot_type_){arena}
    , decltype(_impl_.opt_frame_){nullptr}
    , decltype(_impl_.trajectory_opt_){nullptr}
    , decltype(_impl_.kinematics_opt_){nullptr}
    , decltype(_impl_.tolerance_opt_){nullptr}
    , decltype(_impl_.obstacles_opt_){nullptr}
    , decltype(_impl_.optimize_info_){nullptr}
    , decltype(_impl_.hcp_opt_){nullptr}
    , decltype(_impl_.recovery_info_){nullptr}
  };
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Config)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Config::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.robot_type_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.opt_frame_;
  if (this != internal_default_instance()) delete _impl_.trajectory_opt_;
  if (this != internal_default_instance()) delete _impl_.kinematics_opt_;
  if (this != internal_default_instance()) delete _impl_.tolerance_opt_;
  if (this != internal_default_instance()) delete _impl_.obstacles_opt_;
  if (this != internal_default_instance()) delete _impl_.optimize_info_;
  if (this != internal_default_instance()) delete _impl_.hcp_opt_;
  if (this != internal_default_instance()) delete _impl_.recovery_info_;
}

void Config::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Config::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Config)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.robot_type_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.opt_frame_ != nullptr);
      _impl_.opt_frame_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.trajectory_opt_ != nullptr);
      _impl_.trajectory_opt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.kinematics_opt_ != nullptr);
      _impl_.kinematics_opt_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.tolerance_opt_ != nullptr);
      _impl_.tolerance_opt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.obstacles_opt_ != nullptr);
      _impl_.obstacles_opt_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.optimize_info_ != nullptr);
      _impl_.optimize_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.hcp_opt_ != nullptr);
      _impl_.hcp_opt_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.recovery_info_ != nullptr);
      _impl_.recovery_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Config::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .roborts_local_planner.FrameID opt_frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_opt_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trajectory_opt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.Robot kinematics_opt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_kinematics_opt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tolerance_opt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_obstacles_opt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.Optimization optimize_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimize_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_hcp_opt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_local_planner.FootprintModel robot_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot_type(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_local_planner.Recovery recovery_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_recovery_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Config::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Config)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .roborts_local_planner.FrameID opt_frame = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::opt_frame(this),
        _Internal::opt_frame(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::trajectory_opt(this),
        _Internal::trajectory_opt(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.Robot kinematics_opt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::kinematics_opt(this),
        _Internal::kinematics_opt(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::tolerance_opt(this),
        _Internal::tolerance_opt(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::obstacles_opt(this),
        _Internal::obstacles_opt(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.Optimization optimize_info = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::optimize_info(this),
        _Internal::optimize_info(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::hcp_opt(this),
        _Internal::hcp_opt(this).GetCachedSize(), target, stream);
  }

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_robot_type_size()); i < n; i++) {
    const auto& repfield = this->_internal_robot_type(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .roborts_local_planner.Recovery recovery_info = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::recovery_info(this),
        _Internal::recovery_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Config)
  return target;
}

size_t Config::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Config)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  total_size += 1UL * this->_internal_robot_type_size();
  for (const auto& msg : this->_impl_.robot_type_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .roborts_local_planner.FrameID opt_frame = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.opt_frame_);
    }

    // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trajectory_opt_);
    }

    // optional .roborts_local_planner.Robot kinematics_opt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kinematics_opt_);
    }

    // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tolerance_opt_);
    }

    // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obstacles_opt_);
    }

    // optional .roborts_local_planner.Optimization optimize_info = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.optimize_info_);
    }

    // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hcp_opt_);
    }

    // optional .roborts_local_planner.Recovery recovery_info = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recovery_info_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Config::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Config::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Config::GetClassData() const { return &_class_data_; }


void Config::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Config*>(&to_msg);
  auto& from = static_cast<const Config&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Config)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.robot_type_.MergeFrom(from._impl_.robot_type_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_opt_frame()->::roborts_local_planner::FrameID::MergeFrom(
          from._internal_opt_frame());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_trajectory_opt()->::roborts_local_planner::Trajectory::MergeFrom(
          from._internal_trajectory_opt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_kinematics_opt()->::roborts_local_planner::Robot::MergeFrom(
          from._internal_kinematics_opt());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_tolerance_opt()->::roborts_local_planner::GoalTolerance::MergeFrom(
          from._internal_tolerance_opt());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_obstacles_opt()->::roborts_local_planner::Obstacles::MergeFrom(
          from._internal_obstacles_opt());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_optimize_info()->::roborts_local_planner::Optimization::MergeFrom(
          from._internal_optimize_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_hcp_opt()->::roborts_local_planner::HomotopyClassPlanner::MergeFrom(
          from._internal_hcp_opt());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_recovery_info()->::roborts_local_planner::Recovery::MergeFrom(
          from._internal_recovery_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Config::CopyFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {
  return true;
}

void Config::InternalSwap(Config* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.robot_type_.InternalSwap(&other->_impl_.robot_type_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Config, _impl_.recovery_info_)
      + sizeof(Config::_impl_.recovery_info_)
      - PROTOBUF_FIELD_OFFSET(Config, _impl_.opt_frame_)>(
          reinterpret_cast<char*>(&_impl_.opt_frame_),
          reinterpret_cast<char*>(&other->_impl_.opt_frame_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Config::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_timed_5felastic_5fband_2eproto_getter, &descriptor_table_timed_5felastic_5fband_2eproto_once,
      file_level_metadata_timed_5felastic_5fband_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace roborts_local_planner
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::roborts_local_planner::FrameID*
Arena::CreateMaybeMessage< ::roborts_local_planner::FrameID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::FrameID >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Point2D*
Arena::CreateMaybeMessage< ::roborts_local_planner::Point2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Point2D >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Trajectory*
Arena::CreateMaybeMessage< ::roborts_local_planner::Trajectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Trajectory >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::FootprintModel*
Arena::CreateMaybeMessage< ::roborts_local_planner::FootprintModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::FootprintModel >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Robot*
Arena::CreateMaybeMessage< ::roborts_local_planner::Robot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Robot >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::GoalTolerance*
Arena::CreateMaybeMessage< ::roborts_local_planner::GoalTolerance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::GoalTolerance >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Obstacles*
Arena::CreateMaybeMessage< ::roborts_local_planner::Obstacles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Optimization*
Arena::CreateMaybeMessage< ::roborts_local_planner::Optimization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Optimization >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::HomotopyClassPlanner*
Arena::CreateMaybeMessage< ::roborts_local_planner::HomotopyClassPlanner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::HomotopyClassPlanner >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Recovery*
Arena::CreateMaybeMessage< ::roborts_local_planner::Recovery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Recovery >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_local_planner::Config*
Arena::CreateMaybeMessage< ::roborts_local_planner::Config >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_local_planner::Config >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
