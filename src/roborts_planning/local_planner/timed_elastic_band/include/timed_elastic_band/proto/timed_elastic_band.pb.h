// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_timed_5felastic_5fband_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_timed_5felastic_5fband_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_timed_5felastic_5fband_2eproto;
namespace roborts_local_planner {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class FootprintModel;
struct FootprintModelDefaultTypeInternal;
extern FootprintModelDefaultTypeInternal _FootprintModel_default_instance_;
class FrameID;
struct FrameIDDefaultTypeInternal;
extern FrameIDDefaultTypeInternal _FrameID_default_instance_;
class GoalTolerance;
struct GoalToleranceDefaultTypeInternal;
extern GoalToleranceDefaultTypeInternal _GoalTolerance_default_instance_;
class HomotopyClassPlanner;
struct HomotopyClassPlannerDefaultTypeInternal;
extern HomotopyClassPlannerDefaultTypeInternal _HomotopyClassPlanner_default_instance_;
class Obstacles;
struct ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Optimization;
struct OptimizationDefaultTypeInternal;
extern OptimizationDefaultTypeInternal _Optimization_default_instance_;
class Point2D;
struct Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Recovery;
struct RecoveryDefaultTypeInternal;
extern RecoveryDefaultTypeInternal _Recovery_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Trajectory;
struct TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace roborts_local_planner
PROTOBUF_NAMESPACE_OPEN
template<> ::roborts_local_planner::Config* Arena::CreateMaybeMessage<::roborts_local_planner::Config>(Arena*);
template<> ::roborts_local_planner::FootprintModel* Arena::CreateMaybeMessage<::roborts_local_planner::FootprintModel>(Arena*);
template<> ::roborts_local_planner::FrameID* Arena::CreateMaybeMessage<::roborts_local_planner::FrameID>(Arena*);
template<> ::roborts_local_planner::GoalTolerance* Arena::CreateMaybeMessage<::roborts_local_planner::GoalTolerance>(Arena*);
template<> ::roborts_local_planner::HomotopyClassPlanner* Arena::CreateMaybeMessage<::roborts_local_planner::HomotopyClassPlanner>(Arena*);
template<> ::roborts_local_planner::Obstacles* Arena::CreateMaybeMessage<::roborts_local_planner::Obstacles>(Arena*);
template<> ::roborts_local_planner::Optimization* Arena::CreateMaybeMessage<::roborts_local_planner::Optimization>(Arena*);
template<> ::roborts_local_planner::Point2D* Arena::CreateMaybeMessage<::roborts_local_planner::Point2D>(Arena*);
template<> ::roborts_local_planner::Recovery* Arena::CreateMaybeMessage<::roborts_local_planner::Recovery>(Arena*);
template<> ::roborts_local_planner::Robot* Arena::CreateMaybeMessage<::roborts_local_planner::Robot>(Arena*);
template<> ::roborts_local_planner::Trajectory* Arena::CreateMaybeMessage<::roborts_local_planner::Trajectory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace roborts_local_planner {

enum FootprintModel_FootprintType : int {
  FootprintModel_FootprintType_POINT = 0,
  FootprintModel_FootprintType_CIRCULAR = 1,
  FootprintModel_FootprintType_TWOCIRCLES = 2,
  FootprintModel_FootprintType_LINE = 3,
  FootprintModel_FootprintType_POLYGON = 4
};
bool FootprintModel_FootprintType_IsValid(int value);
constexpr FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MIN = FootprintModel_FootprintType_POINT;
constexpr FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MAX = FootprintModel_FootprintType_POLYGON;
constexpr int FootprintModel_FootprintType_FootprintType_ARRAYSIZE = FootprintModel_FootprintType_FootprintType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootprintModel_FootprintType_descriptor();
template<typename T>
inline const std::string& FootprintModel_FootprintType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FootprintModel_FootprintType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FootprintModel_FootprintType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FootprintModel_FootprintType_descriptor(), enum_t_value);
}
inline bool FootprintModel_FootprintType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FootprintModel_FootprintType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FootprintModel_FootprintType>(
    FootprintModel_FootprintType_descriptor(), name, value);
}
// ===================================================================

class FrameID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.FrameID) */ {
 public:
  inline FrameID() : FrameID(nullptr) {}
  ~FrameID() override;
  explicit PROTOBUF_CONSTEXPR FrameID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameID(const FrameID& from);
  FrameID(FrameID&& from) noexcept
    : FrameID() {
    *this = ::std::move(from);
  }

  inline FrameID& operator=(const FrameID& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameID& operator=(FrameID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameID& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameID* internal_default_instance() {
    return reinterpret_cast<const FrameID*>(
               &_FrameID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FrameID& a, FrameID& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameID& from) {
    FrameID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.FrameID";
  }
  protected:
  explicit FrameID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOdomFrameFieldNumber = 1,
    kMapFrameFieldNumber = 2,
  };
  // optional string odom_frame = 1;
  bool has_odom_frame() const;
  private:
  bool _internal_has_odom_frame() const;
  public:
  void clear_odom_frame();
  const std::string& odom_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_odom_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_odom_frame();
  PROTOBUF_NODISCARD std::string* release_odom_frame();
  void set_allocated_odom_frame(std::string* odom_frame);
  private:
  const std::string& _internal_odom_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_odom_frame(const std::string& value);
  std::string* _internal_mutable_odom_frame();
  public:

  // optional string map_frame = 2;
  bool has_map_frame() const;
  private:
  bool _internal_has_map_frame() const;
  public:
  void clear_map_frame();
  const std::string& map_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_frame();
  PROTOBUF_NODISCARD std::string* release_map_frame();
  void set_allocated_map_frame(std::string* map_frame);
  private:
  const std::string& _internal_map_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_frame(const std::string& value);
  std::string* _internal_mutable_map_frame();
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.FrameID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr odom_frame_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Point2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Point2D) */ {
 public:
  inline Point2D() : Point2D(nullptr) {}
  ~Point2D() override;
  explicit PROTOBUF_CONSTEXPR Point2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2D(const Point2D& from);
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2D& operator=(Point2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point2D& from) {
    Point2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Point2D";
  }
  protected:
  explicit Point2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Point2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Trajectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Trajectory) */ {
 public:
  inline Trajectory() : Trajectory(nullptr) {}
  ~Trajectory() override;
  explicit PROTOBUF_CONSTEXPR Trajectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trajectory(const Trajectory& from);
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trajectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trajectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trajectory& from) {
    Trajectory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Trajectory";
  }
  protected:
  explicit Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDtRefFieldNumber = 2,
    kDtHysteresisFieldNumber = 3,
    kTebAutosizeFieldNumber = 1,
    kGlobalPlanOverwriteOrientationFieldNumber = 4,
    kAllowInitWithBackwardsMotionFieldNumber = 5,
    kViaPointsOrderedFieldNumber = 7,
    kGlobalPlanViapointSepFieldNumber = 6,
    kMaxGlobalPlanLookaheadDistFieldNumber = 8,
    kForceReinitNewGoalDistFieldNumber = 10,
    kFeasibilityCheckNoPosesFieldNumber = 11,
    kMinSamplesFieldNumber = 13,
    kMaxSamplesFieldNumber = 14,
    kExactArcLengthFieldNumber = 9,
    kPublishFeedbackFieldNumber = 12,
  };
  // optional float dt_ref = 2;
  bool has_dt_ref() const;
  private:
  bool _internal_has_dt_ref() const;
  public:
  void clear_dt_ref();
  float dt_ref() const;
  void set_dt_ref(float value);
  private:
  float _internal_dt_ref() const;
  void _internal_set_dt_ref(float value);
  public:

  // optional float dt_hysteresis = 3;
  bool has_dt_hysteresis() const;
  private:
  bool _internal_has_dt_hysteresis() const;
  public:
  void clear_dt_hysteresis();
  float dt_hysteresis() const;
  void set_dt_hysteresis(float value);
  private:
  float _internal_dt_hysteresis() const;
  void _internal_set_dt_hysteresis(float value);
  public:

  // optional bool teb_autosize = 1;
  bool has_teb_autosize() const;
  private:
  bool _internal_has_teb_autosize() const;
  public:
  void clear_teb_autosize();
  bool teb_autosize() const;
  void set_teb_autosize(bool value);
  private:
  bool _internal_teb_autosize() const;
  void _internal_set_teb_autosize(bool value);
  public:

  // optional bool global_plan_overwrite_orientation = 4;
  bool has_global_plan_overwrite_orientation() const;
  private:
  bool _internal_has_global_plan_overwrite_orientation() const;
  public:
  void clear_global_plan_overwrite_orientation();
  bool global_plan_overwrite_orientation() const;
  void set_global_plan_overwrite_orientation(bool value);
  private:
  bool _internal_global_plan_overwrite_orientation() const;
  void _internal_set_global_plan_overwrite_orientation(bool value);
  public:

  // optional bool allow_init_with_backwards_motion = 5;
  bool has_allow_init_with_backwards_motion() const;
  private:
  bool _internal_has_allow_init_with_backwards_motion() const;
  public:
  void clear_allow_init_with_backwards_motion();
  bool allow_init_with_backwards_motion() const;
  void set_allow_init_with_backwards_motion(bool value);
  private:
  bool _internal_allow_init_with_backwards_motion() const;
  void _internal_set_allow_init_with_backwards_motion(bool value);
  public:

  // optional bool via_points_ordered = 7;
  bool has_via_points_ordered() const;
  private:
  bool _internal_has_via_points_ordered() const;
  public:
  void clear_via_points_ordered();
  bool via_points_ordered() const;
  void set_via_points_ordered(bool value);
  private:
  bool _internal_via_points_ordered() const;
  void _internal_set_via_points_ordered(bool value);
  public:

  // optional float global_plan_viapoint_sep = 6;
  bool has_global_plan_viapoint_sep() const;
  private:
  bool _internal_has_global_plan_viapoint_sep() const;
  public:
  void clear_global_plan_viapoint_sep();
  float global_plan_viapoint_sep() const;
  void set_global_plan_viapoint_sep(float value);
  private:
  float _internal_global_plan_viapoint_sep() const;
  void _internal_set_global_plan_viapoint_sep(float value);
  public:

  // optional float max_global_plan_lookahead_dist = 8;
  bool has_max_global_plan_lookahead_dist() const;
  private:
  bool _internal_has_max_global_plan_lookahead_dist() const;
  public:
  void clear_max_global_plan_lookahead_dist();
  float max_global_plan_lookahead_dist() const;
  void set_max_global_plan_lookahead_dist(float value);
  private:
  float _internal_max_global_plan_lookahead_dist() const;
  void _internal_set_max_global_plan_lookahead_dist(float value);
  public:

  // optional float force_reinit_new_goal_dist = 10;
  bool has_force_reinit_new_goal_dist() const;
  private:
  bool _internal_has_force_reinit_new_goal_dist() const;
  public:
  void clear_force_reinit_new_goal_dist();
  float force_reinit_new_goal_dist() const;
  void set_force_reinit_new_goal_dist(float value);
  private:
  float _internal_force_reinit_new_goal_dist() const;
  void _internal_set_force_reinit_new_goal_dist(float value);
  public:

  // optional int64 feasibility_check_no_poses = 11;
  bool has_feasibility_check_no_poses() const;
  private:
  bool _internal_has_feasibility_check_no_poses() const;
  public:
  void clear_feasibility_check_no_poses();
  int64_t feasibility_check_no_poses() const;
  void set_feasibility_check_no_poses(int64_t value);
  private:
  int64_t _internal_feasibility_check_no_poses() const;
  void _internal_set_feasibility_check_no_poses(int64_t value);
  public:

  // optional int64 min_samples = 13;
  bool has_min_samples() const;
  private:
  bool _internal_has_min_samples() const;
  public:
  void clear_min_samples();
  int64_t min_samples() const;
  void set_min_samples(int64_t value);
  private:
  int64_t _internal_min_samples() const;
  void _internal_set_min_samples(int64_t value);
  public:

  // optional int64 max_samples = 14;
  bool has_max_samples() const;
  private:
  bool _internal_has_max_samples() const;
  public:
  void clear_max_samples();
  int64_t max_samples() const;
  void set_max_samples(int64_t value);
  private:
  int64_t _internal_max_samples() const;
  void _internal_set_max_samples(int64_t value);
  public:

  // optional bool exact_arc_length = 9;
  bool has_exact_arc_length() const;
  private:
  bool _internal_has_exact_arc_length() const;
  public:
  void clear_exact_arc_length();
  bool exact_arc_length() const;
  void set_exact_arc_length(bool value);
  private:
  bool _internal_exact_arc_length() const;
  void _internal_set_exact_arc_length(bool value);
  public:

  // optional bool publish_feedback = 12;
  bool has_publish_feedback() const;
  private:
  bool _internal_has_publish_feedback() const;
  public:
  void clear_publish_feedback();
  bool publish_feedback() const;
  void set_publish_feedback(bool value);
  private:
  bool _internal_publish_feedback() const;
  void _internal_set_publish_feedback(bool value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Trajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float dt_ref_;
    float dt_hysteresis_;
    bool teb_autosize_;
    bool global_plan_overwrite_orientation_;
    bool allow_init_with_backwards_motion_;
    bool via_points_ordered_;
    float global_plan_viapoint_sep_;
    float max_global_plan_lookahead_dist_;
    float force_reinit_new_goal_dist_;
    int64_t feasibility_check_no_poses_;
    int64_t min_samples_;
    int64_t max_samples_;
    bool exact_arc_length_;
    bool publish_feedback_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class FootprintModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.FootprintModel) */ {
 public:
  inline FootprintModel() : FootprintModel(nullptr) {}
  ~FootprintModel() override;
  explicit PROTOBUF_CONSTEXPR FootprintModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FootprintModel(const FootprintModel& from);
  FootprintModel(FootprintModel&& from) noexcept
    : FootprintModel() {
    *this = ::std::move(from);
  }

  inline FootprintModel& operator=(const FootprintModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootprintModel& operator=(FootprintModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootprintModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootprintModel* internal_default_instance() {
    return reinterpret_cast<const FootprintModel*>(
               &_FootprintModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FootprintModel& a, FootprintModel& b) {
    a.Swap(&b);
  }
  inline void Swap(FootprintModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootprintModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootprintModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootprintModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FootprintModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FootprintModel& from) {
    FootprintModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootprintModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.FootprintModel";
  }
  protected:
  explicit FootprintModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FootprintModel_FootprintType FootprintType;
  static constexpr FootprintType POINT =
    FootprintModel_FootprintType_POINT;
  static constexpr FootprintType CIRCULAR =
    FootprintModel_FootprintType_CIRCULAR;
  static constexpr FootprintType TWOCIRCLES =
    FootprintModel_FootprintType_TWOCIRCLES;
  static constexpr FootprintType LINE =
    FootprintModel_FootprintType_LINE;
  static constexpr FootprintType POLYGON =
    FootprintModel_FootprintType_POLYGON;
  static inline bool FootprintType_IsValid(int value) {
    return FootprintModel_FootprintType_IsValid(value);
  }
  static constexpr FootprintType FootprintType_MIN =
    FootprintModel_FootprintType_FootprintType_MIN;
  static constexpr FootprintType FootprintType_MAX =
    FootprintModel_FootprintType_FootprintType_MAX;
  static constexpr int FootprintType_ARRAYSIZE =
    FootprintModel_FootprintType_FootprintType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FootprintType_descriptor() {
    return FootprintModel_FootprintType_descriptor();
  }
  template<typename T>
  static inline const std::string& FootprintType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FootprintType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FootprintType_Name.");
    return FootprintModel_FootprintType_Name(enum_t_value);
  }
  static inline bool FootprintType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FootprintType* value) {
    return FootprintModel_FootprintType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRobotVerticesFieldNumber = 7,
    kRadiusFieldNumber = 2,
    kFrontOffsetFieldNumber = 3,
    kFrontRadiusFieldNumber = 4,
    kRearOffsetFieldNumber = 5,
    kRearRadiusFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  int robot_vertices_size() const;
  private:
  int _internal_robot_vertices_size() const;
  public:
  void clear_robot_vertices();
  ::roborts_local_planner::Point2D* mutable_robot_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::Point2D >*
      mutable_robot_vertices();
  private:
  const ::roborts_local_planner::Point2D& _internal_robot_vertices(int index) const;
  ::roborts_local_planner::Point2D* _internal_add_robot_vertices();
  public:
  const ::roborts_local_planner::Point2D& robot_vertices(int index) const;
  ::roborts_local_planner::Point2D* add_robot_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::Point2D >&
      robot_vertices() const;

  // optional double radius = 2;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // optional double front_offset = 3;
  bool has_front_offset() const;
  private:
  bool _internal_has_front_offset() const;
  public:
  void clear_front_offset();
  double front_offset() const;
  void set_front_offset(double value);
  private:
  double _internal_front_offset() const;
  void _internal_set_front_offset(double value);
  public:

  // optional double front_radius = 4;
  bool has_front_radius() const;
  private:
  bool _internal_has_front_radius() const;
  public:
  void clear_front_radius();
  double front_radius() const;
  void set_front_radius(double value);
  private:
  double _internal_front_radius() const;
  void _internal_set_front_radius(double value);
  public:

  // optional double rear_offset = 5;
  bool has_rear_offset() const;
  private:
  bool _internal_has_rear_offset() const;
  public:
  void clear_rear_offset();
  double rear_offset() const;
  void set_rear_offset(double value);
  private:
  double _internal_rear_offset() const;
  void _internal_set_rear_offset(double value);
  public:

  // optional double rear_radius = 6;
  bool has_rear_radius() const;
  private:
  bool _internal_has_rear_radius() const;
  public:
  void clear_rear_radius();
  double rear_radius() const;
  void set_rear_radius(double value);
  private:
  double _internal_rear_radius() const;
  void _internal_set_rear_radius(double value);
  public:

  // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::roborts_local_planner::FootprintModel_FootprintType type() const;
  void set_type(::roborts_local_planner::FootprintModel_FootprintType value);
  private:
  ::roborts_local_planner::FootprintModel_FootprintType _internal_type() const;
  void _internal_set_type(::roborts_local_planner::FootprintModel_FootprintType value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.FootprintModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::Point2D > robot_vertices_;
    double radius_;
    double front_offset_;
    double front_radius_;
    double rear_offset_;
    double rear_radius_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxVelXFieldNumber = 1,
    kMaxVelXBackwardsFieldNumber = 2,
    kMaxVelYFieldNumber = 3,
    kMaxVelThetaFieldNumber = 4,
    kAccLimXFieldNumber = 5,
    kAccLimYFieldNumber = 6,
    kAccLimThetaFieldNumber = 7,
    kMinTurningRadiusFieldNumber = 8,
    kWheelbaseFieldNumber = 9,
    kCmdAngleInsteadRotvelFieldNumber = 10,
  };
  // optional float max_vel_x = 1;
  bool has_max_vel_x() const;
  private:
  bool _internal_has_max_vel_x() const;
  public:
  void clear_max_vel_x();
  float max_vel_x() const;
  void set_max_vel_x(float value);
  private:
  float _internal_max_vel_x() const;
  void _internal_set_max_vel_x(float value);
  public:

  // optional float max_vel_x_backwards = 2;
  bool has_max_vel_x_backwards() const;
  private:
  bool _internal_has_max_vel_x_backwards() const;
  public:
  void clear_max_vel_x_backwards();
  float max_vel_x_backwards() const;
  void set_max_vel_x_backwards(float value);
  private:
  float _internal_max_vel_x_backwards() const;
  void _internal_set_max_vel_x_backwards(float value);
  public:

  // optional float max_vel_y = 3;
  bool has_max_vel_y() const;
  private:
  bool _internal_has_max_vel_y() const;
  public:
  void clear_max_vel_y();
  float max_vel_y() const;
  void set_max_vel_y(float value);
  private:
  float _internal_max_vel_y() const;
  void _internal_set_max_vel_y(float value);
  public:

  // optional float max_vel_theta = 4;
  bool has_max_vel_theta() const;
  private:
  bool _internal_has_max_vel_theta() const;
  public:
  void clear_max_vel_theta();
  float max_vel_theta() const;
  void set_max_vel_theta(float value);
  private:
  float _internal_max_vel_theta() const;
  void _internal_set_max_vel_theta(float value);
  public:

  // optional float acc_lim_x = 5;
  bool has_acc_lim_x() const;
  private:
  bool _internal_has_acc_lim_x() const;
  public:
  void clear_acc_lim_x();
  float acc_lim_x() const;
  void set_acc_lim_x(float value);
  private:
  float _internal_acc_lim_x() const;
  void _internal_set_acc_lim_x(float value);
  public:

  // optional float acc_lim_y = 6;
  bool has_acc_lim_y() const;
  private:
  bool _internal_has_acc_lim_y() const;
  public:
  void clear_acc_lim_y();
  float acc_lim_y() const;
  void set_acc_lim_y(float value);
  private:
  float _internal_acc_lim_y() const;
  void _internal_set_acc_lim_y(float value);
  public:

  // optional float acc_lim_theta = 7;
  bool has_acc_lim_theta() const;
  private:
  bool _internal_has_acc_lim_theta() const;
  public:
  void clear_acc_lim_theta();
  float acc_lim_theta() const;
  void set_acc_lim_theta(float value);
  private:
  float _internal_acc_lim_theta() const;
  void _internal_set_acc_lim_theta(float value);
  public:

  // optional float min_turning_radius = 8;
  bool has_min_turning_radius() const;
  private:
  bool _internal_has_min_turning_radius() const;
  public:
  void clear_min_turning_radius();
  float min_turning_radius() const;
  void set_min_turning_radius(float value);
  private:
  float _internal_min_turning_radius() const;
  void _internal_set_min_turning_radius(float value);
  public:

  // optional float wheelbase = 9;
  bool has_wheelbase() const;
  private:
  bool _internal_has_wheelbase() const;
  public:
  void clear_wheelbase();
  float wheelbase() const;
  void set_wheelbase(float value);
  private:
  float _internal_wheelbase() const;
  void _internal_set_wheelbase(float value);
  public:

  // optional bool cmd_angle_instead_rotvel = 10;
  bool has_cmd_angle_instead_rotvel() const;
  private:
  bool _internal_has_cmd_angle_instead_rotvel() const;
  public:
  void clear_cmd_angle_instead_rotvel();
  bool cmd_angle_instead_rotvel() const;
  void set_cmd_angle_instead_rotvel(bool value);
  private:
  bool _internal_cmd_angle_instead_rotvel() const;
  void _internal_set_cmd_angle_instead_rotvel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float max_vel_x_;
    float max_vel_x_backwards_;
    float max_vel_y_;
    float max_vel_theta_;
    float acc_lim_x_;
    float acc_lim_y_;
    float acc_lim_theta_;
    float min_turning_radius_;
    float wheelbase_;
    bool cmd_angle_instead_rotvel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class GoalTolerance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.GoalTolerance) */ {
 public:
  inline GoalTolerance() : GoalTolerance(nullptr) {}
  ~GoalTolerance() override;
  explicit PROTOBUF_CONSTEXPR GoalTolerance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GoalTolerance(const GoalTolerance& from);
  GoalTolerance(GoalTolerance&& from) noexcept
    : GoalTolerance() {
    *this = ::std::move(from);
  }

  inline GoalTolerance& operator=(const GoalTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalTolerance& operator=(GoalTolerance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalTolerance& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoalTolerance* internal_default_instance() {
    return reinterpret_cast<const GoalTolerance*>(
               &_GoalTolerance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GoalTolerance& a, GoalTolerance& b) {
    a.Swap(&b);
  }
  inline void Swap(GoalTolerance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalTolerance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalTolerance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoalTolerance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GoalTolerance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GoalTolerance& from) {
    GoalTolerance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoalTolerance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.GoalTolerance";
  }
  protected:
  explicit GoalTolerance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyGoalToleranceFieldNumber = 1,
    kYawGoalToleranceFieldNumber = 2,
    kFreeGoalVelFieldNumber = 3,
  };
  // optional float xy_goal_tolerance = 1;
  bool has_xy_goal_tolerance() const;
  private:
  bool _internal_has_xy_goal_tolerance() const;
  public:
  void clear_xy_goal_tolerance();
  float xy_goal_tolerance() const;
  void set_xy_goal_tolerance(float value);
  private:
  float _internal_xy_goal_tolerance() const;
  void _internal_set_xy_goal_tolerance(float value);
  public:

  // optional float yaw_goal_tolerance = 2;
  bool has_yaw_goal_tolerance() const;
  private:
  bool _internal_has_yaw_goal_tolerance() const;
  public:
  void clear_yaw_goal_tolerance();
  float yaw_goal_tolerance() const;
  void set_yaw_goal_tolerance(float value);
  private:
  float _internal_yaw_goal_tolerance() const;
  void _internal_set_yaw_goal_tolerance(float value);
  public:

  // optional bool free_goal_vel = 3;
  bool has_free_goal_vel() const;
  private:
  bool _internal_has_free_goal_vel() const;
  public:
  void clear_free_goal_vel();
  bool free_goal_vel() const;
  void set_free_goal_vel(bool value);
  private:
  bool _internal_free_goal_vel() const;
  void _internal_set_free_goal_vel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.GoalTolerance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float xy_goal_tolerance_;
    float yaw_goal_tolerance_;
    bool free_goal_vel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Obstacles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Obstacles) */ {
 public:
  inline Obstacles() : Obstacles(nullptr) {}
  ~Obstacles() override;
  explicit PROTOBUF_CONSTEXPR Obstacles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacles(const Obstacles& from);
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Obstacles& from) {
    Obstacles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Obstacles";
  }
  protected:
  explicit Obstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCostmapConverterPluginFieldNumber = 9,
    kMinObstacleDistFieldNumber = 1,
    kInflationDistFieldNumber = 2,
    kCostmapObstaclesBehindRobotDistFieldNumber = 4,
    kObstaclePosesAffectedFieldNumber = 5,
    kIncludeCostmapObstaclesFieldNumber = 3,
    kLegacyObstacleAssociationFieldNumber = 6,
    kCostmapConverterSpinThreadFieldNumber = 10,
    kObstacleAssociationCutoffFactorFieldNumber = 7,
    kObstacleAssociationForceInclusionFactorFieldNumber = 8,
    kCostmapConverterRateFieldNumber = 11,
  };
  // optional string costmap_converter_plugin = 9;
  bool has_costmap_converter_plugin() const;
  private:
  bool _internal_has_costmap_converter_plugin() const;
  public:
  void clear_costmap_converter_plugin();
  const std::string& costmap_converter_plugin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_costmap_converter_plugin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_costmap_converter_plugin();
  PROTOBUF_NODISCARD std::string* release_costmap_converter_plugin();
  void set_allocated_costmap_converter_plugin(std::string* costmap_converter_plugin);
  private:
  const std::string& _internal_costmap_converter_plugin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_costmap_converter_plugin(const std::string& value);
  std::string* _internal_mutable_costmap_converter_plugin();
  public:

  // optional float min_obstacle_dist = 1;
  bool has_min_obstacle_dist() const;
  private:
  bool _internal_has_min_obstacle_dist() const;
  public:
  void clear_min_obstacle_dist();
  float min_obstacle_dist() const;
  void set_min_obstacle_dist(float value);
  private:
  float _internal_min_obstacle_dist() const;
  void _internal_set_min_obstacle_dist(float value);
  public:

  // optional float inflation_dist = 2;
  bool has_inflation_dist() const;
  private:
  bool _internal_has_inflation_dist() const;
  public:
  void clear_inflation_dist();
  float inflation_dist() const;
  void set_inflation_dist(float value);
  private:
  float _internal_inflation_dist() const;
  void _internal_set_inflation_dist(float value);
  public:

  // optional float costmap_obstacles_behind_robot_dist = 4;
  bool has_costmap_obstacles_behind_robot_dist() const;
  private:
  bool _internal_has_costmap_obstacles_behind_robot_dist() const;
  public:
  void clear_costmap_obstacles_behind_robot_dist();
  float costmap_obstacles_behind_robot_dist() const;
  void set_costmap_obstacles_behind_robot_dist(float value);
  private:
  float _internal_costmap_obstacles_behind_robot_dist() const;
  void _internal_set_costmap_obstacles_behind_robot_dist(float value);
  public:

  // optional float obstacle_poses_affected = 5;
  bool has_obstacle_poses_affected() const;
  private:
  bool _internal_has_obstacle_poses_affected() const;
  public:
  void clear_obstacle_poses_affected();
  float obstacle_poses_affected() const;
  void set_obstacle_poses_affected(float value);
  private:
  float _internal_obstacle_poses_affected() const;
  void _internal_set_obstacle_poses_affected(float value);
  public:

  // optional bool include_costmap_obstacles = 3;
  bool has_include_costmap_obstacles() const;
  private:
  bool _internal_has_include_costmap_obstacles() const;
  public:
  void clear_include_costmap_obstacles();
  bool include_costmap_obstacles() const;
  void set_include_costmap_obstacles(bool value);
  private:
  bool _internal_include_costmap_obstacles() const;
  void _internal_set_include_costmap_obstacles(bool value);
  public:

  // optional bool legacy_obstacle_association = 6;
  bool has_legacy_obstacle_association() const;
  private:
  bool _internal_has_legacy_obstacle_association() const;
  public:
  void clear_legacy_obstacle_association();
  bool legacy_obstacle_association() const;
  void set_legacy_obstacle_association(bool value);
  private:
  bool _internal_legacy_obstacle_association() const;
  void _internal_set_legacy_obstacle_association(bool value);
  public:

  // optional bool costmap_converter_spin_thread = 10;
  bool has_costmap_converter_spin_thread() const;
  private:
  bool _internal_has_costmap_converter_spin_thread() const;
  public:
  void clear_costmap_converter_spin_thread();
  bool costmap_converter_spin_thread() const;
  void set_costmap_converter_spin_thread(bool value);
  private:
  bool _internal_costmap_converter_spin_thread() const;
  void _internal_set_costmap_converter_spin_thread(bool value);
  public:

  // optional float obstacle_association_cutoff_factor = 7;
  bool has_obstacle_association_cutoff_factor() const;
  private:
  bool _internal_has_obstacle_association_cutoff_factor() const;
  public:
  void clear_obstacle_association_cutoff_factor();
  float obstacle_association_cutoff_factor() const;
  void set_obstacle_association_cutoff_factor(float value);
  private:
  float _internal_obstacle_association_cutoff_factor() const;
  void _internal_set_obstacle_association_cutoff_factor(float value);
  public:

  // optional float obstacle_association_force_inclusion_factor = 8;
  bool has_obstacle_association_force_inclusion_factor() const;
  private:
  bool _internal_has_obstacle_association_force_inclusion_factor() const;
  public:
  void clear_obstacle_association_force_inclusion_factor();
  float obstacle_association_force_inclusion_factor() const;
  void set_obstacle_association_force_inclusion_factor(float value);
  private:
  float _internal_obstacle_association_force_inclusion_factor() const;
  void _internal_set_obstacle_association_force_inclusion_factor(float value);
  public:

  // optional float costmap_converter_rate = 11;
  bool has_costmap_converter_rate() const;
  private:
  bool _internal_has_costmap_converter_rate() const;
  public:
  void clear_costmap_converter_rate();
  float costmap_converter_rate() const;
  void set_costmap_converter_rate(float value);
  private:
  float _internal_costmap_converter_rate() const;
  void _internal_set_costmap_converter_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Obstacles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr costmap_converter_plugin_;
    float min_obstacle_dist_;
    float inflation_dist_;
    float costmap_obstacles_behind_robot_dist_;
    float obstacle_poses_affected_;
    bool include_costmap_obstacles_;
    bool legacy_obstacle_association_;
    bool costmap_converter_spin_thread_;
    float obstacle_association_cutoff_factor_;
    float obstacle_association_force_inclusion_factor_;
    float costmap_converter_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Optimization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Optimization) */ {
 public:
  inline Optimization() : Optimization(nullptr) {}
  ~Optimization() override;
  explicit PROTOBUF_CONSTEXPR Optimization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optimization(const Optimization& from);
  Optimization(Optimization&& from) noexcept
    : Optimization() {
    *this = ::std::move(from);
  }

  inline Optimization& operator=(const Optimization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optimization& operator=(Optimization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optimization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optimization* internal_default_instance() {
    return reinterpret_cast<const Optimization*>(
               &_Optimization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Optimization& a, Optimization& b) {
    a.Swap(&b);
  }
  inline void Swap(Optimization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optimization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optimization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optimization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optimization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optimization& from) {
    Optimization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optimization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Optimization";
  }
  protected:
  explicit Optimization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoInnerIterationsFieldNumber = 1,
    kNoOuterIterationsFieldNumber = 2,
    kOptimizationActivateFieldNumber = 3,
    kOptimizationVerboseFieldNumber = 4,
    kPenaltyEpsilonFieldNumber = 5,
    kWeightMaxVelXFieldNumber = 6,
    kWeightMaxVelYFieldNumber = 7,
    kWeightMaxVelThetaFieldNumber = 8,
    kWeightAccLimXFieldNumber = 9,
    kWeightAccLimYFieldNumber = 10,
    kWeightAccLimThetFieldNumber = 11,
    kWeightKinematicsNhFieldNumber = 12,
    kWeightKinematicsForwardDriveFieldNumber = 13,
    kWeightKinematicsTurningRadiusFieldNumber = 14,
    kWeightOptimaltimeFieldNumber = 15,
    kWeightObstacleFieldNumber = 16,
    kWeightInflationFieldNumber = 17,
    kWeightDynamicObstacleFieldNumber = 18,
    kWeightViapointFieldNumber = 19,
    kWeightAdaptFactorFieldNumber = 20,
    kWeightPreferRotdirFieldNumber = 21,
    kWeightAccLimThetaFieldNumber = 22,
  };
  // optional int32 no_inner_iterations = 1;
  bool has_no_inner_iterations() const;
  private:
  bool _internal_has_no_inner_iterations() const;
  public:
  void clear_no_inner_iterations();
  int32_t no_inner_iterations() const;
  void set_no_inner_iterations(int32_t value);
  private:
  int32_t _internal_no_inner_iterations() const;
  void _internal_set_no_inner_iterations(int32_t value);
  public:

  // optional int32 no_outer_iterations = 2;
  bool has_no_outer_iterations() const;
  private:
  bool _internal_has_no_outer_iterations() const;
  public:
  void clear_no_outer_iterations();
  int32_t no_outer_iterations() const;
  void set_no_outer_iterations(int32_t value);
  private:
  int32_t _internal_no_outer_iterations() const;
  void _internal_set_no_outer_iterations(int32_t value);
  public:

  // optional bool optimization_activate = 3;
  bool has_optimization_activate() const;
  private:
  bool _internal_has_optimization_activate() const;
  public:
  void clear_optimization_activate();
  bool optimization_activate() const;
  void set_optimization_activate(bool value);
  private:
  bool _internal_optimization_activate() const;
  void _internal_set_optimization_activate(bool value);
  public:

  // optional bool optimization_verbose = 4;
  bool has_optimization_verbose() const;
  private:
  bool _internal_has_optimization_verbose() const;
  public:
  void clear_optimization_verbose();
  bool optimization_verbose() const;
  void set_optimization_verbose(bool value);
  private:
  bool _internal_optimization_verbose() const;
  void _internal_set_optimization_verbose(bool value);
  public:

  // optional float penalty_epsilon = 5;
  bool has_penalty_epsilon() const;
  private:
  bool _internal_has_penalty_epsilon() const;
  public:
  void clear_penalty_epsilon();
  float penalty_epsilon() const;
  void set_penalty_epsilon(float value);
  private:
  float _internal_penalty_epsilon() const;
  void _internal_set_penalty_epsilon(float value);
  public:

  // optional float weight_max_vel_x = 6;
  bool has_weight_max_vel_x() const;
  private:
  bool _internal_has_weight_max_vel_x() const;
  public:
  void clear_weight_max_vel_x();
  float weight_max_vel_x() const;
  void set_weight_max_vel_x(float value);
  private:
  float _internal_weight_max_vel_x() const;
  void _internal_set_weight_max_vel_x(float value);
  public:

  // optional float weight_max_vel_y = 7;
  bool has_weight_max_vel_y() const;
  private:
  bool _internal_has_weight_max_vel_y() const;
  public:
  void clear_weight_max_vel_y();
  float weight_max_vel_y() const;
  void set_weight_max_vel_y(float value);
  private:
  float _internal_weight_max_vel_y() const;
  void _internal_set_weight_max_vel_y(float value);
  public:

  // optional float weight_max_vel_theta = 8;
  bool has_weight_max_vel_theta() const;
  private:
  bool _internal_has_weight_max_vel_theta() const;
  public:
  void clear_weight_max_vel_theta();
  float weight_max_vel_theta() const;
  void set_weight_max_vel_theta(float value);
  private:
  float _internal_weight_max_vel_theta() const;
  void _internal_set_weight_max_vel_theta(float value);
  public:

  // optional float weight_acc_lim_x = 9;
  bool has_weight_acc_lim_x() const;
  private:
  bool _internal_has_weight_acc_lim_x() const;
  public:
  void clear_weight_acc_lim_x();
  float weight_acc_lim_x() const;
  void set_weight_acc_lim_x(float value);
  private:
  float _internal_weight_acc_lim_x() const;
  void _internal_set_weight_acc_lim_x(float value);
  public:

  // optional float weight_acc_lim_y = 10;
  bool has_weight_acc_lim_y() const;
  private:
  bool _internal_has_weight_acc_lim_y() const;
  public:
  void clear_weight_acc_lim_y();
  float weight_acc_lim_y() const;
  void set_weight_acc_lim_y(float value);
  private:
  float _internal_weight_acc_lim_y() const;
  void _internal_set_weight_acc_lim_y(float value);
  public:

  // optional float weight_acc_lim_thet = 11;
  bool has_weight_acc_lim_thet() const;
  private:
  bool _internal_has_weight_acc_lim_thet() const;
  public:
  void clear_weight_acc_lim_thet();
  float weight_acc_lim_thet() const;
  void set_weight_acc_lim_thet(float value);
  private:
  float _internal_weight_acc_lim_thet() const;
  void _internal_set_weight_acc_lim_thet(float value);
  public:

  // optional float weight_kinematics_nh = 12;
  bool has_weight_kinematics_nh() const;
  private:
  bool _internal_has_weight_kinematics_nh() const;
  public:
  void clear_weight_kinematics_nh();
  float weight_kinematics_nh() const;
  void set_weight_kinematics_nh(float value);
  private:
  float _internal_weight_kinematics_nh() const;
  void _internal_set_weight_kinematics_nh(float value);
  public:

  // optional float weight_kinematics_forward_drive = 13;
  bool has_weight_kinematics_forward_drive() const;
  private:
  bool _internal_has_weight_kinematics_forward_drive() const;
  public:
  void clear_weight_kinematics_forward_drive();
  float weight_kinematics_forward_drive() const;
  void set_weight_kinematics_forward_drive(float value);
  private:
  float _internal_weight_kinematics_forward_drive() const;
  void _internal_set_weight_kinematics_forward_drive(float value);
  public:

  // optional float weight_kinematics_turning_radius = 14;
  bool has_weight_kinematics_turning_radius() const;
  private:
  bool _internal_has_weight_kinematics_turning_radius() const;
  public:
  void clear_weight_kinematics_turning_radius();
  float weight_kinematics_turning_radius() const;
  void set_weight_kinematics_turning_radius(float value);
  private:
  float _internal_weight_kinematics_turning_radius() const;
  void _internal_set_weight_kinematics_turning_radius(float value);
  public:

  // optional float weight_optimaltime = 15;
  bool has_weight_optimaltime() const;
  private:
  bool _internal_has_weight_optimaltime() const;
  public:
  void clear_weight_optimaltime();
  float weight_optimaltime() const;
  void set_weight_optimaltime(float value);
  private:
  float _internal_weight_optimaltime() const;
  void _internal_set_weight_optimaltime(float value);
  public:

  // optional float weight_obstacle = 16;
  bool has_weight_obstacle() const;
  private:
  bool _internal_has_weight_obstacle() const;
  public:
  void clear_weight_obstacle();
  float weight_obstacle() const;
  void set_weight_obstacle(float value);
  private:
  float _internal_weight_obstacle() const;
  void _internal_set_weight_obstacle(float value);
  public:

  // optional float weight_inflation = 17;
  bool has_weight_inflation() const;
  private:
  bool _internal_has_weight_inflation() const;
  public:
  void clear_weight_inflation();
  float weight_inflation() const;
  void set_weight_inflation(float value);
  private:
  float _internal_weight_inflation() const;
  void _internal_set_weight_inflation(float value);
  public:

  // optional float weight_dynamic_obstacle = 18;
  bool has_weight_dynamic_obstacle() const;
  private:
  bool _internal_has_weight_dynamic_obstacle() const;
  public:
  void clear_weight_dynamic_obstacle();
  float weight_dynamic_obstacle() const;
  void set_weight_dynamic_obstacle(float value);
  private:
  float _internal_weight_dynamic_obstacle() const;
  void _internal_set_weight_dynamic_obstacle(float value);
  public:

  // optional float weight_viapoint = 19;
  bool has_weight_viapoint() const;
  private:
  bool _internal_has_weight_viapoint() const;
  public:
  void clear_weight_viapoint();
  float weight_viapoint() const;
  void set_weight_viapoint(float value);
  private:
  float _internal_weight_viapoint() const;
  void _internal_set_weight_viapoint(float value);
  public:

  // optional float weight_adapt_factor = 20;
  bool has_weight_adapt_factor() const;
  private:
  bool _internal_has_weight_adapt_factor() const;
  public:
  void clear_weight_adapt_factor();
  float weight_adapt_factor() const;
  void set_weight_adapt_factor(float value);
  private:
  float _internal_weight_adapt_factor() const;
  void _internal_set_weight_adapt_factor(float value);
  public:

  // optional float weight_prefer_rotdir = 21;
  bool has_weight_prefer_rotdir() const;
  private:
  bool _internal_has_weight_prefer_rotdir() const;
  public:
  void clear_weight_prefer_rotdir();
  float weight_prefer_rotdir() const;
  void set_weight_prefer_rotdir(float value);
  private:
  float _internal_weight_prefer_rotdir() const;
  void _internal_set_weight_prefer_rotdir(float value);
  public:

  // optional float weight_acc_lim_theta = 22;
  bool has_weight_acc_lim_theta() const;
  private:
  bool _internal_has_weight_acc_lim_theta() const;
  public:
  void clear_weight_acc_lim_theta();
  float weight_acc_lim_theta() const;
  void set_weight_acc_lim_theta(float value);
  private:
  float _internal_weight_acc_lim_theta() const;
  void _internal_set_weight_acc_lim_theta(float value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Optimization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t no_inner_iterations_;
    int32_t no_outer_iterations_;
    bool optimization_activate_;
    bool optimization_verbose_;
    float penalty_epsilon_;
    float weight_max_vel_x_;
    float weight_max_vel_y_;
    float weight_max_vel_theta_;
    float weight_acc_lim_x_;
    float weight_acc_lim_y_;
    float weight_acc_lim_thet_;
    float weight_kinematics_nh_;
    float weight_kinematics_forward_drive_;
    float weight_kinematics_turning_radius_;
    float weight_optimaltime_;
    float weight_obstacle_;
    float weight_inflation_;
    float weight_dynamic_obstacle_;
    float weight_viapoint_;
    float weight_adapt_factor_;
    float weight_prefer_rotdir_;
    float weight_acc_lim_theta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class HomotopyClassPlanner final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.HomotopyClassPlanner) */ {
 public:
  inline HomotopyClassPlanner() : HomotopyClassPlanner(nullptr) {}
  ~HomotopyClassPlanner() override;
  explicit PROTOBUF_CONSTEXPR HomotopyClassPlanner(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HomotopyClassPlanner(const HomotopyClassPlanner& from);
  HomotopyClassPlanner(HomotopyClassPlanner&& from) noexcept
    : HomotopyClassPlanner() {
    *this = ::std::move(from);
  }

  inline HomotopyClassPlanner& operator=(const HomotopyClassPlanner& from) {
    CopyFrom(from);
    return *this;
  }
  inline HomotopyClassPlanner& operator=(HomotopyClassPlanner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HomotopyClassPlanner& default_instance() {
    return *internal_default_instance();
  }
  static inline const HomotopyClassPlanner* internal_default_instance() {
    return reinterpret_cast<const HomotopyClassPlanner*>(
               &_HomotopyClassPlanner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HomotopyClassPlanner& a, HomotopyClassPlanner& b) {
    a.Swap(&b);
  }
  inline void Swap(HomotopyClassPlanner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HomotopyClassPlanner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HomotopyClassPlanner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HomotopyClassPlanner>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HomotopyClassPlanner& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HomotopyClassPlanner& from) {
    HomotopyClassPlanner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HomotopyClassPlanner* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.HomotopyClassPlanner";
  }
  protected:
  explicit HomotopyClassPlanner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableHomotopyClassPlanningFieldNumber = 1,
    kEnableMultithreadingFieldNumber = 2,
    kSimpleExplorationFieldNumber = 3,
    kSelectionAlternativeTimeCostFieldNumber = 9,
    kMaxNumberClassesFieldNumber = 4,
    kSelectionObstCostScaleFieldNumber = 5,
    kSelectionPreferInitialPlanFieldNumber = 6,
    kSelectionViapointCostScaleFieldNumber = 7,
    kSelectionCostHysteresisFieldNumber = 8,
    kRoadmapGraphNoSamplesFieldNumber = 10,
    kRoadmapGraphAreaWidthFieldNumber = 11,
    kRoadmapGraphAreaLengthScaleFieldNumber = 12,
    kHSignaturePrescalerFieldNumber = 13,
    kHSignatureThresholdFieldNumber = 14,
    kObstacleKeypointOffsetFieldNumber = 15,
    kObstacleHeadingThresholdFieldNumber = 16,
    kViapointsAllCandidatesFieldNumber = 17,
    kVisualizeHcGraphFieldNumber = 18,
  };
  // optional bool enable_homotopy_class_planning = 1;
  bool has_enable_homotopy_class_planning() const;
  private:
  bool _internal_has_enable_homotopy_class_planning() const;
  public:
  void clear_enable_homotopy_class_planning();
  bool enable_homotopy_class_planning() const;
  void set_enable_homotopy_class_planning(bool value);
  private:
  bool _internal_enable_homotopy_class_planning() const;
  void _internal_set_enable_homotopy_class_planning(bool value);
  public:

  // optional bool enable_multithreading = 2;
  bool has_enable_multithreading() const;
  private:
  bool _internal_has_enable_multithreading() const;
  public:
  void clear_enable_multithreading();
  bool enable_multithreading() const;
  void set_enable_multithreading(bool value);
  private:
  bool _internal_enable_multithreading() const;
  void _internal_set_enable_multithreading(bool value);
  public:

  // optional bool simple_exploration = 3;
  bool has_simple_exploration() const;
  private:
  bool _internal_has_simple_exploration() const;
  public:
  void clear_simple_exploration();
  bool simple_exploration() const;
  void set_simple_exploration(bool value);
  private:
  bool _internal_simple_exploration() const;
  void _internal_set_simple_exploration(bool value);
  public:

  // optional bool selection_alternative_time_cost = 9;
  bool has_selection_alternative_time_cost() const;
  private:
  bool _internal_has_selection_alternative_time_cost() const;
  public:
  void clear_selection_alternative_time_cost();
  bool selection_alternative_time_cost() const;
  void set_selection_alternative_time_cost(bool value);
  private:
  bool _internal_selection_alternative_time_cost() const;
  void _internal_set_selection_alternative_time_cost(bool value);
  public:

  // optional int32 max_number_classes = 4;
  bool has_max_number_classes() const;
  private:
  bool _internal_has_max_number_classes() const;
  public:
  void clear_max_number_classes();
  int32_t max_number_classes() const;
  void set_max_number_classes(int32_t value);
  private:
  int32_t _internal_max_number_classes() const;
  void _internal_set_max_number_classes(int32_t value);
  public:

  // optional float selection_obst_cost_scale = 5;
  bool has_selection_obst_cost_scale() const;
  private:
  bool _internal_has_selection_obst_cost_scale() const;
  public:
  void clear_selection_obst_cost_scale();
  float selection_obst_cost_scale() const;
  void set_selection_obst_cost_scale(float value);
  private:
  float _internal_selection_obst_cost_scale() const;
  void _internal_set_selection_obst_cost_scale(float value);
  public:

  // optional float selection_prefer_initial_plan = 6;
  bool has_selection_prefer_initial_plan() const;
  private:
  bool _internal_has_selection_prefer_initial_plan() const;
  public:
  void clear_selection_prefer_initial_plan();
  float selection_prefer_initial_plan() const;
  void set_selection_prefer_initial_plan(float value);
  private:
  float _internal_selection_prefer_initial_plan() const;
  void _internal_set_selection_prefer_initial_plan(float value);
  public:

  // optional float selection_viapoint_cost_scale = 7;
  bool has_selection_viapoint_cost_scale() const;
  private:
  bool _internal_has_selection_viapoint_cost_scale() const;
  public:
  void clear_selection_viapoint_cost_scale();
  float selection_viapoint_cost_scale() const;
  void set_selection_viapoint_cost_scale(float value);
  private:
  float _internal_selection_viapoint_cost_scale() const;
  void _internal_set_selection_viapoint_cost_scale(float value);
  public:

  // optional float selection_cost_hysteresis = 8;
  bool has_selection_cost_hysteresis() const;
  private:
  bool _internal_has_selection_cost_hysteresis() const;
  public:
  void clear_selection_cost_hysteresis();
  float selection_cost_hysteresis() const;
  void set_selection_cost_hysteresis(float value);
  private:
  float _internal_selection_cost_hysteresis() const;
  void _internal_set_selection_cost_hysteresis(float value);
  public:

  // optional int32 roadmap_graph_no_samples = 10;
  bool has_roadmap_graph_no_samples() const;
  private:
  bool _internal_has_roadmap_graph_no_samples() const;
  public:
  void clear_roadmap_graph_no_samples();
  int32_t roadmap_graph_no_samples() const;
  void set_roadmap_graph_no_samples(int32_t value);
  private:
  int32_t _internal_roadmap_graph_no_samples() const;
  void _internal_set_roadmap_graph_no_samples(int32_t value);
  public:

  // optional int32 roadmap_graph_area_width = 11;
  bool has_roadmap_graph_area_width() const;
  private:
  bool _internal_has_roadmap_graph_area_width() const;
  public:
  void clear_roadmap_graph_area_width();
  int32_t roadmap_graph_area_width() const;
  void set_roadmap_graph_area_width(int32_t value);
  private:
  int32_t _internal_roadmap_graph_area_width() const;
  void _internal_set_roadmap_graph_area_width(int32_t value);
  public:

  // optional float roadmap_graph_area_length_scale = 12;
  bool has_roadmap_graph_area_length_scale() const;
  private:
  bool _internal_has_roadmap_graph_area_length_scale() const;
  public:
  void clear_roadmap_graph_area_length_scale();
  float roadmap_graph_area_length_scale() const;
  void set_roadmap_graph_area_length_scale(float value);
  private:
  float _internal_roadmap_graph_area_length_scale() const;
  void _internal_set_roadmap_graph_area_length_scale(float value);
  public:

  // optional float h_signature_prescaler = 13;
  bool has_h_signature_prescaler() const;
  private:
  bool _internal_has_h_signature_prescaler() const;
  public:
  void clear_h_signature_prescaler();
  float h_signature_prescaler() const;
  void set_h_signature_prescaler(float value);
  private:
  float _internal_h_signature_prescaler() const;
  void _internal_set_h_signature_prescaler(float value);
  public:

  // optional float h_signature_threshold = 14;
  bool has_h_signature_threshold() const;
  private:
  bool _internal_has_h_signature_threshold() const;
  public:
  void clear_h_signature_threshold();
  float h_signature_threshold() const;
  void set_h_signature_threshold(float value);
  private:
  float _internal_h_signature_threshold() const;
  void _internal_set_h_signature_threshold(float value);
  public:

  // optional float obstacle_keypoint_offset = 15;
  bool has_obstacle_keypoint_offset() const;
  private:
  bool _internal_has_obstacle_keypoint_offset() const;
  public:
  void clear_obstacle_keypoint_offset();
  float obstacle_keypoint_offset() const;
  void set_obstacle_keypoint_offset(float value);
  private:
  float _internal_obstacle_keypoint_offset() const;
  void _internal_set_obstacle_keypoint_offset(float value);
  public:

  // optional float obstacle_heading_threshold = 16;
  bool has_obstacle_heading_threshold() const;
  private:
  bool _internal_has_obstacle_heading_threshold() const;
  public:
  void clear_obstacle_heading_threshold();
  float obstacle_heading_threshold() const;
  void set_obstacle_heading_threshold(float value);
  private:
  float _internal_obstacle_heading_threshold() const;
  void _internal_set_obstacle_heading_threshold(float value);
  public:

  // optional bool viapoints_all_candidates = 17;
  bool has_viapoints_all_candidates() const;
  private:
  bool _internal_has_viapoints_all_candidates() const;
  public:
  void clear_viapoints_all_candidates();
  bool viapoints_all_candidates() const;
  void set_viapoints_all_candidates(bool value);
  private:
  bool _internal_viapoints_all_candidates() const;
  void _internal_set_viapoints_all_candidates(bool value);
  public:

  // optional bool visualize_hc_graph = 18;
  bool has_visualize_hc_graph() const;
  private:
  bool _internal_has_visualize_hc_graph() const;
  public:
  void clear_visualize_hc_graph();
  bool visualize_hc_graph() const;
  void set_visualize_hc_graph(bool value);
  private:
  bool _internal_visualize_hc_graph() const;
  void _internal_set_visualize_hc_graph(bool value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.HomotopyClassPlanner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_homotopy_class_planning_;
    bool enable_multithreading_;
    bool simple_exploration_;
    bool selection_alternative_time_cost_;
    int32_t max_number_classes_;
    float selection_obst_cost_scale_;
    float selection_prefer_initial_plan_;
    float selection_viapoint_cost_scale_;
    float selection_cost_hysteresis_;
    int32_t roadmap_graph_no_samples_;
    int32_t roadmap_graph_area_width_;
    float roadmap_graph_area_length_scale_;
    float h_signature_prescaler_;
    float h_signature_threshold_;
    float obstacle_keypoint_offset_;
    float obstacle_heading_threshold_;
    bool viapoints_all_candidates_;
    bool visualize_hc_graph_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Recovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Recovery) */ {
 public:
  inline Recovery() : Recovery(nullptr) {}
  ~Recovery() override;
  explicit PROTOBUF_CONSTEXPR Recovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Recovery(const Recovery& from);
  Recovery(Recovery&& from) noexcept
    : Recovery() {
    *this = ::std::move(from);
  }

  inline Recovery& operator=(const Recovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recovery& operator=(Recovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Recovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Recovery* internal_default_instance() {
    return reinterpret_cast<const Recovery*>(
               &_Recovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Recovery& a, Recovery& b) {
    a.Swap(&b);
  }
  inline void Swap(Recovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Recovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Recovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Recovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Recovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Recovery& from) {
    Recovery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Recovery";
  }
  protected:
  explicit Recovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOscillationVEpsFieldNumber = 4,
    kOscillationOmegaEpsFieldNumber = 5,
    kOscillationRecoveryMinDurationFieldNumber = 6,
    kOscillationFilterDurationFieldNumber = 7,
    kShrinkHorizonMinDurationFieldNumber = 1,
    kOscillationRecoveryFieldNumber = 2,
    kShrinkHorizonBackupFieldNumber = 3,
  };
  // optional double oscillation_v_eps = 4;
  bool has_oscillation_v_eps() const;
  private:
  bool _internal_has_oscillation_v_eps() const;
  public:
  void clear_oscillation_v_eps();
  double oscillation_v_eps() const;
  void set_oscillation_v_eps(double value);
  private:
  double _internal_oscillation_v_eps() const;
  void _internal_set_oscillation_v_eps(double value);
  public:

  // optional double oscillation_omega_eps = 5;
  bool has_oscillation_omega_eps() const;
  private:
  bool _internal_has_oscillation_omega_eps() const;
  public:
  void clear_oscillation_omega_eps();
  double oscillation_omega_eps() const;
  void set_oscillation_omega_eps(double value);
  private:
  double _internal_oscillation_omega_eps() const;
  void _internal_set_oscillation_omega_eps(double value);
  public:

  // optional double oscillation_recovery_min_duration = 6;
  bool has_oscillation_recovery_min_duration() const;
  private:
  bool _internal_has_oscillation_recovery_min_duration() const;
  public:
  void clear_oscillation_recovery_min_duration();
  double oscillation_recovery_min_duration() const;
  void set_oscillation_recovery_min_duration(double value);
  private:
  double _internal_oscillation_recovery_min_duration() const;
  void _internal_set_oscillation_recovery_min_duration(double value);
  public:

  // optional double oscillation_filter_duration = 7;
  bool has_oscillation_filter_duration() const;
  private:
  bool _internal_has_oscillation_filter_duration() const;
  public:
  void clear_oscillation_filter_duration();
  double oscillation_filter_duration() const;
  void set_oscillation_filter_duration(double value);
  private:
  double _internal_oscillation_filter_duration() const;
  void _internal_set_oscillation_filter_duration(double value);
  public:

  // optional bool shrink_horizon_min_duration = 1;
  bool has_shrink_horizon_min_duration() const;
  private:
  bool _internal_has_shrink_horizon_min_duration() const;
  public:
  void clear_shrink_horizon_min_duration();
  bool shrink_horizon_min_duration() const;
  void set_shrink_horizon_min_duration(bool value);
  private:
  bool _internal_shrink_horizon_min_duration() const;
  void _internal_set_shrink_horizon_min_duration(bool value);
  public:

  // optional bool oscillation_recovery = 2;
  bool has_oscillation_recovery() const;
  private:
  bool _internal_has_oscillation_recovery() const;
  public:
  void clear_oscillation_recovery();
  bool oscillation_recovery() const;
  void set_oscillation_recovery(bool value);
  private:
  bool _internal_oscillation_recovery() const;
  void _internal_set_oscillation_recovery(bool value);
  public:

  // optional bool shrink_horizon_backup = 3;
  bool has_shrink_horizon_backup() const;
  private:
  bool _internal_has_shrink_horizon_backup() const;
  public:
  void clear_shrink_horizon_backup();
  bool shrink_horizon_backup() const;
  void set_shrink_horizon_backup(bool value);
  private:
  bool _internal_shrink_horizon_backup() const;
  void _internal_set_shrink_horizon_backup(bool value);
  public:

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Recovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double oscillation_v_eps_;
    double oscillation_omega_eps_;
    double oscillation_recovery_min_duration_;
    double oscillation_filter_duration_;
    bool shrink_horizon_min_duration_;
    bool oscillation_recovery_;
    bool shrink_horizon_backup_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit PROTOBUF_CONSTEXPR Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "roborts_local_planner.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotTypeFieldNumber = 8,
    kOptFrameFieldNumber = 1,
    kTrajectoryOptFieldNumber = 2,
    kKinematicsOptFieldNumber = 3,
    kToleranceOptFieldNumber = 4,
    kObstaclesOptFieldNumber = 5,
    kOptimizeInfoFieldNumber = 6,
    kHcpOptFieldNumber = 7,
    kRecoveryInfoFieldNumber = 9,
  };
  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  int robot_type_size() const;
  private:
  int _internal_robot_type_size() const;
  public:
  void clear_robot_type();
  ::roborts_local_planner::FootprintModel* mutable_robot_type(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::FootprintModel >*
      mutable_robot_type();
  private:
  const ::roborts_local_planner::FootprintModel& _internal_robot_type(int index) const;
  ::roborts_local_planner::FootprintModel* _internal_add_robot_type();
  public:
  const ::roborts_local_planner::FootprintModel& robot_type(int index) const;
  ::roborts_local_planner::FootprintModel* add_robot_type();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::FootprintModel >&
      robot_type() const;

  // optional .roborts_local_planner.FrameID opt_frame = 1;
  bool has_opt_frame() const;
  private:
  bool _internal_has_opt_frame() const;
  public:
  void clear_opt_frame();
  const ::roborts_local_planner::FrameID& opt_frame() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::FrameID* release_opt_frame();
  ::roborts_local_planner::FrameID* mutable_opt_frame();
  void set_allocated_opt_frame(::roborts_local_planner::FrameID* opt_frame);
  private:
  const ::roborts_local_planner::FrameID& _internal_opt_frame() const;
  ::roborts_local_planner::FrameID* _internal_mutable_opt_frame();
  public:
  void unsafe_arena_set_allocated_opt_frame(
      ::roborts_local_planner::FrameID* opt_frame);
  ::roborts_local_planner::FrameID* unsafe_arena_release_opt_frame();

  // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
  bool has_trajectory_opt() const;
  private:
  bool _internal_has_trajectory_opt() const;
  public:
  void clear_trajectory_opt();
  const ::roborts_local_planner::Trajectory& trajectory_opt() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::Trajectory* release_trajectory_opt();
  ::roborts_local_planner::Trajectory* mutable_trajectory_opt();
  void set_allocated_trajectory_opt(::roborts_local_planner::Trajectory* trajectory_opt);
  private:
  const ::roborts_local_planner::Trajectory& _internal_trajectory_opt() const;
  ::roborts_local_planner::Trajectory* _internal_mutable_trajectory_opt();
  public:
  void unsafe_arena_set_allocated_trajectory_opt(
      ::roborts_local_planner::Trajectory* trajectory_opt);
  ::roborts_local_planner::Trajectory* unsafe_arena_release_trajectory_opt();

  // optional .roborts_local_planner.Robot kinematics_opt = 3;
  bool has_kinematics_opt() const;
  private:
  bool _internal_has_kinematics_opt() const;
  public:
  void clear_kinematics_opt();
  const ::roborts_local_planner::Robot& kinematics_opt() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::Robot* release_kinematics_opt();
  ::roborts_local_planner::Robot* mutable_kinematics_opt();
  void set_allocated_kinematics_opt(::roborts_local_planner::Robot* kinematics_opt);
  private:
  const ::roborts_local_planner::Robot& _internal_kinematics_opt() const;
  ::roborts_local_planner::Robot* _internal_mutable_kinematics_opt();
  public:
  void unsafe_arena_set_allocated_kinematics_opt(
      ::roborts_local_planner::Robot* kinematics_opt);
  ::roborts_local_planner::Robot* unsafe_arena_release_kinematics_opt();

  // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
  bool has_tolerance_opt() const;
  private:
  bool _internal_has_tolerance_opt() const;
  public:
  void clear_tolerance_opt();
  const ::roborts_local_planner::GoalTolerance& tolerance_opt() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::GoalTolerance* release_tolerance_opt();
  ::roborts_local_planner::GoalTolerance* mutable_tolerance_opt();
  void set_allocated_tolerance_opt(::roborts_local_planner::GoalTolerance* tolerance_opt);
  private:
  const ::roborts_local_planner::GoalTolerance& _internal_tolerance_opt() const;
  ::roborts_local_planner::GoalTolerance* _internal_mutable_tolerance_opt();
  public:
  void unsafe_arena_set_allocated_tolerance_opt(
      ::roborts_local_planner::GoalTolerance* tolerance_opt);
  ::roborts_local_planner::GoalTolerance* unsafe_arena_release_tolerance_opt();

  // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
  bool has_obstacles_opt() const;
  private:
  bool _internal_has_obstacles_opt() const;
  public:
  void clear_obstacles_opt();
  const ::roborts_local_planner::Obstacles& obstacles_opt() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::Obstacles* release_obstacles_opt();
  ::roborts_local_planner::Obstacles* mutable_obstacles_opt();
  void set_allocated_obstacles_opt(::roborts_local_planner::Obstacles* obstacles_opt);
  private:
  const ::roborts_local_planner::Obstacles& _internal_obstacles_opt() const;
  ::roborts_local_planner::Obstacles* _internal_mutable_obstacles_opt();
  public:
  void unsafe_arena_set_allocated_obstacles_opt(
      ::roborts_local_planner::Obstacles* obstacles_opt);
  ::roborts_local_planner::Obstacles* unsafe_arena_release_obstacles_opt();

  // optional .roborts_local_planner.Optimization optimize_info = 6;
  bool has_optimize_info() const;
  private:
  bool _internal_has_optimize_info() const;
  public:
  void clear_optimize_info();
  const ::roborts_local_planner::Optimization& optimize_info() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::Optimization* release_optimize_info();
  ::roborts_local_planner::Optimization* mutable_optimize_info();
  void set_allocated_optimize_info(::roborts_local_planner::Optimization* optimize_info);
  private:
  const ::roborts_local_planner::Optimization& _internal_optimize_info() const;
  ::roborts_local_planner::Optimization* _internal_mutable_optimize_info();
  public:
  void unsafe_arena_set_allocated_optimize_info(
      ::roborts_local_planner::Optimization* optimize_info);
  ::roborts_local_planner::Optimization* unsafe_arena_release_optimize_info();

  // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
  bool has_hcp_opt() const;
  private:
  bool _internal_has_hcp_opt() const;
  public:
  void clear_hcp_opt();
  const ::roborts_local_planner::HomotopyClassPlanner& hcp_opt() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::HomotopyClassPlanner* release_hcp_opt();
  ::roborts_local_planner::HomotopyClassPlanner* mutable_hcp_opt();
  void set_allocated_hcp_opt(::roborts_local_planner::HomotopyClassPlanner* hcp_opt);
  private:
  const ::roborts_local_planner::HomotopyClassPlanner& _internal_hcp_opt() const;
  ::roborts_local_planner::HomotopyClassPlanner* _internal_mutable_hcp_opt();
  public:
  void unsafe_arena_set_allocated_hcp_opt(
      ::roborts_local_planner::HomotopyClassPlanner* hcp_opt);
  ::roborts_local_planner::HomotopyClassPlanner* unsafe_arena_release_hcp_opt();

  // optional .roborts_local_planner.Recovery recovery_info = 9;
  bool has_recovery_info() const;
  private:
  bool _internal_has_recovery_info() const;
  public:
  void clear_recovery_info();
  const ::roborts_local_planner::Recovery& recovery_info() const;
  PROTOBUF_NODISCARD ::roborts_local_planner::Recovery* release_recovery_info();
  ::roborts_local_planner::Recovery* mutable_recovery_info();
  void set_allocated_recovery_info(::roborts_local_planner::Recovery* recovery_info);
  private:
  const ::roborts_local_planner::Recovery& _internal_recovery_info() const;
  ::roborts_local_planner::Recovery* _internal_mutable_recovery_info();
  public:
  void unsafe_arena_set_allocated_recovery_info(
      ::roborts_local_planner::Recovery* recovery_info);
  ::roborts_local_planner::Recovery* unsafe_arena_release_recovery_info();

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::FootprintModel > robot_type_;
    ::roborts_local_planner::FrameID* opt_frame_;
    ::roborts_local_planner::Trajectory* trajectory_opt_;
    ::roborts_local_planner::Robot* kinematics_opt_;
    ::roborts_local_planner::GoalTolerance* tolerance_opt_;
    ::roborts_local_planner::Obstacles* obstacles_opt_;
    ::roborts_local_planner::Optimization* optimize_info_;
    ::roborts_local_planner::HomotopyClassPlanner* hcp_opt_;
    ::roborts_local_planner::Recovery* recovery_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_timed_5felastic_5fband_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameID

// optional string odom_frame = 1;
inline bool FrameID::_internal_has_odom_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameID::has_odom_frame() const {
  return _internal_has_odom_frame();
}
inline void FrameID::clear_odom_frame() {
  _impl_.odom_frame_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameID::odom_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.odom_frame)
  return _internal_odom_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameID::set_odom_frame(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.odom_frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.odom_frame)
}
inline std::string* FrameID::mutable_odom_frame() {
  std::string* _s = _internal_mutable_odom_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.odom_frame)
  return _s;
}
inline const std::string& FrameID::_internal_odom_frame() const {
  return _impl_.odom_frame_.Get();
}
inline void FrameID::_internal_set_odom_frame(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.odom_frame_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameID::_internal_mutable_odom_frame() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.odom_frame_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameID::release_odom_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.odom_frame)
  if (!_internal_has_odom_frame()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.odom_frame_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.odom_frame_.IsDefault()) {
    _impl_.odom_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameID::set_allocated_odom_frame(std::string* odom_frame) {
  if (odom_frame != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.odom_frame_.SetAllocated(odom_frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.odom_frame_.IsDefault()) {
    _impl_.odom_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.odom_frame)
}

// optional string map_frame = 2;
inline bool FrameID::_internal_has_map_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameID::has_map_frame() const {
  return _internal_has_map_frame();
}
inline void FrameID::clear_map_frame() {
  _impl_.map_frame_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FrameID::map_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.map_frame)
  return _internal_map_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameID::set_map_frame(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.map_frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.map_frame)
}
inline std::string* FrameID::mutable_map_frame() {
  std::string* _s = _internal_mutable_map_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.map_frame)
  return _s;
}
inline const std::string& FrameID::_internal_map_frame() const {
  return _impl_.map_frame_.Get();
}
inline void FrameID::_internal_set_map_frame(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.map_frame_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameID::_internal_mutable_map_frame() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.map_frame_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameID::release_map_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.map_frame)
  if (!_internal_has_map_frame()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.map_frame_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_frame_.IsDefault()) {
    _impl_.map_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameID::set_allocated_map_frame(std::string* map_frame) {
  if (map_frame != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.map_frame_.SetAllocated(map_frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_frame_.IsDefault()) {
    _impl_.map_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.map_frame)
}

// -------------------------------------------------------------------

// Point2D

// optional float x = 1;
inline bool Point2D::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point2D::has_x() const {
  return _internal_has_x();
}
inline void Point2D::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Point2D::_internal_x() const {
  return _impl_.x_;
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.x)
  return _internal_x();
}
inline void Point2D::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Point2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.x)
}

// optional float y = 2;
inline bool Point2D::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point2D::has_y() const {
  return _internal_has_y();
}
inline void Point2D::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Point2D::_internal_y() const {
  return _impl_.y_;
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.y)
  return _internal_y();
}
inline void Point2D::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Point2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.y)
}

// -------------------------------------------------------------------

// Trajectory

// optional bool teb_autosize = 1;
inline bool Trajectory::_internal_has_teb_autosize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Trajectory::has_teb_autosize() const {
  return _internal_has_teb_autosize();
}
inline void Trajectory::clear_teb_autosize() {
  _impl_.teb_autosize_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Trajectory::_internal_teb_autosize() const {
  return _impl_.teb_autosize_;
}
inline bool Trajectory::teb_autosize() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.teb_autosize)
  return _internal_teb_autosize();
}
inline void Trajectory::_internal_set_teb_autosize(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.teb_autosize_ = value;
}
inline void Trajectory::set_teb_autosize(bool value) {
  _internal_set_teb_autosize(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.teb_autosize)
}

// optional float dt_ref = 2;
inline bool Trajectory::_internal_has_dt_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Trajectory::has_dt_ref() const {
  return _internal_has_dt_ref();
}
inline void Trajectory::clear_dt_ref() {
  _impl_.dt_ref_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Trajectory::_internal_dt_ref() const {
  return _impl_.dt_ref_;
}
inline float Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_ref)
  return _internal_dt_ref();
}
inline void Trajectory::_internal_set_dt_ref(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dt_ref_ = value;
}
inline void Trajectory::set_dt_ref(float value) {
  _internal_set_dt_ref(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_ref)
}

// optional float dt_hysteresis = 3;
inline bool Trajectory::_internal_has_dt_hysteresis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Trajectory::has_dt_hysteresis() const {
  return _internal_has_dt_hysteresis();
}
inline void Trajectory::clear_dt_hysteresis() {
  _impl_.dt_hysteresis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Trajectory::_internal_dt_hysteresis() const {
  return _impl_.dt_hysteresis_;
}
inline float Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_hysteresis)
  return _internal_dt_hysteresis();
}
inline void Trajectory::_internal_set_dt_hysteresis(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dt_hysteresis_ = value;
}
inline void Trajectory::set_dt_hysteresis(float value) {
  _internal_set_dt_hysteresis(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_hysteresis)
}

// optional bool global_plan_overwrite_orientation = 4;
inline bool Trajectory::_internal_has_global_plan_overwrite_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Trajectory::has_global_plan_overwrite_orientation() const {
  return _internal_has_global_plan_overwrite_orientation();
}
inline void Trajectory::clear_global_plan_overwrite_orientation() {
  _impl_.global_plan_overwrite_orientation_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Trajectory::_internal_global_plan_overwrite_orientation() const {
  return _impl_.global_plan_overwrite_orientation_;
}
inline bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
  return _internal_global_plan_overwrite_orientation();
}
inline void Trajectory::_internal_set_global_plan_overwrite_orientation(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.global_plan_overwrite_orientation_ = value;
}
inline void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  _internal_set_global_plan_overwrite_orientation(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 5;
inline bool Trajectory::_internal_has_allow_init_with_backwards_motion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Trajectory::has_allow_init_with_backwards_motion() const {
  return _internal_has_allow_init_with_backwards_motion();
}
inline void Trajectory::clear_allow_init_with_backwards_motion() {
  _impl_.allow_init_with_backwards_motion_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Trajectory::_internal_allow_init_with_backwards_motion() const {
  return _impl_.allow_init_with_backwards_motion_;
}
inline bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
  return _internal_allow_init_with_backwards_motion();
}
inline void Trajectory::_internal_set_allow_init_with_backwards_motion(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.allow_init_with_backwards_motion_ = value;
}
inline void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  _internal_set_allow_init_with_backwards_motion(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
}

// optional float global_plan_viapoint_sep = 6;
inline bool Trajectory::_internal_has_global_plan_viapoint_sep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Trajectory::has_global_plan_viapoint_sep() const {
  return _internal_has_global_plan_viapoint_sep();
}
inline void Trajectory::clear_global_plan_viapoint_sep() {
  _impl_.global_plan_viapoint_sep_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Trajectory::_internal_global_plan_viapoint_sep() const {
  return _impl_.global_plan_viapoint_sep_;
}
inline float Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
  return _internal_global_plan_viapoint_sep();
}
inline void Trajectory::_internal_set_global_plan_viapoint_sep(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.global_plan_viapoint_sep_ = value;
}
inline void Trajectory::set_global_plan_viapoint_sep(float value) {
  _internal_set_global_plan_viapoint_sep(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 7;
inline bool Trajectory::_internal_has_via_points_ordered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Trajectory::has_via_points_ordered() const {
  return _internal_has_via_points_ordered();
}
inline void Trajectory::clear_via_points_ordered() {
  _impl_.via_points_ordered_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Trajectory::_internal_via_points_ordered() const {
  return _impl_.via_points_ordered_;
}
inline bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.via_points_ordered)
  return _internal_via_points_ordered();
}
inline void Trajectory::_internal_set_via_points_ordered(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.via_points_ordered_ = value;
}
inline void Trajectory::set_via_points_ordered(bool value) {
  _internal_set_via_points_ordered(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.via_points_ordered)
}

// optional float max_global_plan_lookahead_dist = 8;
inline bool Trajectory::_internal_has_max_global_plan_lookahead_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return _internal_has_max_global_plan_lookahead_dist();
}
inline void Trajectory::clear_max_global_plan_lookahead_dist() {
  _impl_.max_global_plan_lookahead_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Trajectory::_internal_max_global_plan_lookahead_dist() const {
  return _impl_.max_global_plan_lookahead_dist_;
}
inline float Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
  return _internal_max_global_plan_lookahead_dist();
}
inline void Trajectory::_internal_set_max_global_plan_lookahead_dist(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.max_global_plan_lookahead_dist_ = value;
}
inline void Trajectory::set_max_global_plan_lookahead_dist(float value) {
  _internal_set_max_global_plan_lookahead_dist(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
}

// optional bool exact_arc_length = 9;
inline bool Trajectory::_internal_has_exact_arc_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Trajectory::has_exact_arc_length() const {
  return _internal_has_exact_arc_length();
}
inline void Trajectory::clear_exact_arc_length() {
  _impl_.exact_arc_length_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Trajectory::_internal_exact_arc_length() const {
  return _impl_.exact_arc_length_;
}
inline bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.exact_arc_length)
  return _internal_exact_arc_length();
}
inline void Trajectory::_internal_set_exact_arc_length(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.exact_arc_length_ = value;
}
inline void Trajectory::set_exact_arc_length(bool value) {
  _internal_set_exact_arc_length(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.exact_arc_length)
}

// optional float force_reinit_new_goal_dist = 10;
inline bool Trajectory::_internal_has_force_reinit_new_goal_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Trajectory::has_force_reinit_new_goal_dist() const {
  return _internal_has_force_reinit_new_goal_dist();
}
inline void Trajectory::clear_force_reinit_new_goal_dist() {
  _impl_.force_reinit_new_goal_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Trajectory::_internal_force_reinit_new_goal_dist() const {
  return _impl_.force_reinit_new_goal_dist_;
}
inline float Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
  return _internal_force_reinit_new_goal_dist();
}
inline void Trajectory::_internal_set_force_reinit_new_goal_dist(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.force_reinit_new_goal_dist_ = value;
}
inline void Trajectory::set_force_reinit_new_goal_dist(float value) {
  _internal_set_force_reinit_new_goal_dist(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
}

// optional int64 feasibility_check_no_poses = 11;
inline bool Trajectory::_internal_has_feasibility_check_no_poses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Trajectory::has_feasibility_check_no_poses() const {
  return _internal_has_feasibility_check_no_poses();
}
inline void Trajectory::clear_feasibility_check_no_poses() {
  _impl_.feasibility_check_no_poses_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t Trajectory::_internal_feasibility_check_no_poses() const {
  return _impl_.feasibility_check_no_poses_;
}
inline int64_t Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.feasibility_check_no_poses)
  return _internal_feasibility_check_no_poses();
}
inline void Trajectory::_internal_set_feasibility_check_no_poses(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.feasibility_check_no_poses_ = value;
}
inline void Trajectory::set_feasibility_check_no_poses(int64_t value) {
  _internal_set_feasibility_check_no_poses(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 12;
inline bool Trajectory::_internal_has_publish_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Trajectory::has_publish_feedback() const {
  return _internal_has_publish_feedback();
}
inline void Trajectory::clear_publish_feedback() {
  _impl_.publish_feedback_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Trajectory::_internal_publish_feedback() const {
  return _impl_.publish_feedback_;
}
inline bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.publish_feedback)
  return _internal_publish_feedback();
}
inline void Trajectory::_internal_set_publish_feedback(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.publish_feedback_ = value;
}
inline void Trajectory::set_publish_feedback(bool value) {
  _internal_set_publish_feedback(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.publish_feedback)
}

// optional int64 min_samples = 13;
inline bool Trajectory::_internal_has_min_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Trajectory::has_min_samples() const {
  return _internal_has_min_samples();
}
inline void Trajectory::clear_min_samples() {
  _impl_.min_samples_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t Trajectory::_internal_min_samples() const {
  return _impl_.min_samples_;
}
inline int64_t Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.min_samples)
  return _internal_min_samples();
}
inline void Trajectory::_internal_set_min_samples(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.min_samples_ = value;
}
inline void Trajectory::set_min_samples(int64_t value) {
  _internal_set_min_samples(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.min_samples)
}

// optional int64 max_samples = 14;
inline bool Trajectory::_internal_has_max_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Trajectory::has_max_samples() const {
  return _internal_has_max_samples();
}
inline void Trajectory::clear_max_samples() {
  _impl_.max_samples_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t Trajectory::_internal_max_samples() const {
  return _impl_.max_samples_;
}
inline int64_t Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_samples)
  return _internal_max_samples();
}
inline void Trajectory::_internal_set_max_samples(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.max_samples_ = value;
}
inline void Trajectory::set_max_samples(int64_t value) {
  _internal_set_max_samples(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_samples)
}

// -------------------------------------------------------------------

// FootprintModel

// optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
inline bool FootprintModel::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FootprintModel::has_type() const {
  return _internal_has_type();
}
inline void FootprintModel::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::roborts_local_planner::FootprintModel_FootprintType FootprintModel::_internal_type() const {
  return static_cast< ::roborts_local_planner::FootprintModel_FootprintType >(_impl_.type_);
}
inline ::roborts_local_planner::FootprintModel_FootprintType FootprintModel::type() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.type)
  return _internal_type();
}
inline void FootprintModel::_internal_set_type(::roborts_local_planner::FootprintModel_FootprintType value) {
  assert(::roborts_local_planner::FootprintModel_FootprintType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void FootprintModel::set_type(::roborts_local_planner::FootprintModel_FootprintType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.type)
}

// optional double radius = 2;
inline bool FootprintModel::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FootprintModel::has_radius() const {
  return _internal_has_radius();
}
inline void FootprintModel::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double FootprintModel::_internal_radius() const {
  return _impl_.radius_;
}
inline double FootprintModel::radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.radius)
  return _internal_radius();
}
inline void FootprintModel::_internal_set_radius(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.radius_ = value;
}
inline void FootprintModel::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.radius)
}

// optional double front_offset = 3;
inline bool FootprintModel::_internal_has_front_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FootprintModel::has_front_offset() const {
  return _internal_has_front_offset();
}
inline void FootprintModel::clear_front_offset() {
  _impl_.front_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double FootprintModel::_internal_front_offset() const {
  return _impl_.front_offset_;
}
inline double FootprintModel::front_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_offset)
  return _internal_front_offset();
}
inline void FootprintModel::_internal_set_front_offset(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.front_offset_ = value;
}
inline void FootprintModel::set_front_offset(double value) {
  _internal_set_front_offset(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_offset)
}

// optional double front_radius = 4;
inline bool FootprintModel::_internal_has_front_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FootprintModel::has_front_radius() const {
  return _internal_has_front_radius();
}
inline void FootprintModel::clear_front_radius() {
  _impl_.front_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double FootprintModel::_internal_front_radius() const {
  return _impl_.front_radius_;
}
inline double FootprintModel::front_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_radius)
  return _internal_front_radius();
}
inline void FootprintModel::_internal_set_front_radius(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.front_radius_ = value;
}
inline void FootprintModel::set_front_radius(double value) {
  _internal_set_front_radius(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_radius)
}

// optional double rear_offset = 5;
inline bool FootprintModel::_internal_has_rear_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FootprintModel::has_rear_offset() const {
  return _internal_has_rear_offset();
}
inline void FootprintModel::clear_rear_offset() {
  _impl_.rear_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double FootprintModel::_internal_rear_offset() const {
  return _impl_.rear_offset_;
}
inline double FootprintModel::rear_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_offset)
  return _internal_rear_offset();
}
inline void FootprintModel::_internal_set_rear_offset(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rear_offset_ = value;
}
inline void FootprintModel::set_rear_offset(double value) {
  _internal_set_rear_offset(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_offset)
}

// optional double rear_radius = 6;
inline bool FootprintModel::_internal_has_rear_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FootprintModel::has_rear_radius() const {
  return _internal_has_rear_radius();
}
inline void FootprintModel::clear_rear_radius() {
  _impl_.rear_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double FootprintModel::_internal_rear_radius() const {
  return _impl_.rear_radius_;
}
inline double FootprintModel::rear_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_radius)
  return _internal_rear_radius();
}
inline void FootprintModel::_internal_set_rear_radius(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rear_radius_ = value;
}
inline void FootprintModel::set_rear_radius(double value) {
  _internal_set_rear_radius(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_radius)
}

// repeated .roborts_local_planner.Point2D robot_vertices = 7;
inline int FootprintModel::_internal_robot_vertices_size() const {
  return _impl_.robot_vertices_.size();
}
inline int FootprintModel::robot_vertices_size() const {
  return _internal_robot_vertices_size();
}
inline void FootprintModel::clear_robot_vertices() {
  _impl_.robot_vertices_.Clear();
}
inline ::roborts_local_planner::Point2D* FootprintModel::mutable_robot_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FootprintModel.robot_vertices)
  return _impl_.robot_vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::Point2D >*
FootprintModel::mutable_robot_vertices() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.FootprintModel.robot_vertices)
  return &_impl_.robot_vertices_;
}
inline const ::roborts_local_planner::Point2D& FootprintModel::_internal_robot_vertices(int index) const {
  return _impl_.robot_vertices_.Get(index);
}
inline const ::roborts_local_planner::Point2D& FootprintModel::robot_vertices(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.robot_vertices)
  return _internal_robot_vertices(index);
}
inline ::roborts_local_planner::Point2D* FootprintModel::_internal_add_robot_vertices() {
  return _impl_.robot_vertices_.Add();
}
inline ::roborts_local_planner::Point2D* FootprintModel::add_robot_vertices() {
  ::roborts_local_planner::Point2D* _add = _internal_add_robot_vertices();
  // @@protoc_insertion_point(field_add:roborts_local_planner.FootprintModel.robot_vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::Point2D >&
FootprintModel::robot_vertices() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.FootprintModel.robot_vertices)
  return _impl_.robot_vertices_;
}

// -------------------------------------------------------------------

// Robot

// optional float max_vel_x = 1;
inline bool Robot::_internal_has_max_vel_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot::has_max_vel_x() const {
  return _internal_has_max_vel_x();
}
inline void Robot::clear_max_vel_x() {
  _impl_.max_vel_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Robot::_internal_max_vel_x() const {
  return _impl_.max_vel_x_;
}
inline float Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x)
  return _internal_max_vel_x();
}
inline void Robot::_internal_set_max_vel_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_vel_x_ = value;
}
inline void Robot::set_max_vel_x(float value) {
  _internal_set_max_vel_x(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x)
}

// optional float max_vel_x_backwards = 2;
inline bool Robot::_internal_has_max_vel_x_backwards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot::has_max_vel_x_backwards() const {
  return _internal_has_max_vel_x_backwards();
}
inline void Robot::clear_max_vel_x_backwards() {
  _impl_.max_vel_x_backwards_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Robot::_internal_max_vel_x_backwards() const {
  return _impl_.max_vel_x_backwards_;
}
inline float Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x_backwards)
  return _internal_max_vel_x_backwards();
}
inline void Robot::_internal_set_max_vel_x_backwards(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_vel_x_backwards_ = value;
}
inline void Robot::set_max_vel_x_backwards(float value) {
  _internal_set_max_vel_x_backwards(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x_backwards)
}

// optional float max_vel_y = 3;
inline bool Robot::_internal_has_max_vel_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot::has_max_vel_y() const {
  return _internal_has_max_vel_y();
}
inline void Robot::clear_max_vel_y() {
  _impl_.max_vel_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Robot::_internal_max_vel_y() const {
  return _impl_.max_vel_y_;
}
inline float Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_y)
  return _internal_max_vel_y();
}
inline void Robot::_internal_set_max_vel_y(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_vel_y_ = value;
}
inline void Robot::set_max_vel_y(float value) {
  _internal_set_max_vel_y(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_y)
}

// optional float max_vel_theta = 4;
inline bool Robot::_internal_has_max_vel_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Robot::has_max_vel_theta() const {
  return _internal_has_max_vel_theta();
}
inline void Robot::clear_max_vel_theta() {
  _impl_.max_vel_theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Robot::_internal_max_vel_theta() const {
  return _impl_.max_vel_theta_;
}
inline float Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_theta)
  return _internal_max_vel_theta();
}
inline void Robot::_internal_set_max_vel_theta(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_vel_theta_ = value;
}
inline void Robot::set_max_vel_theta(float value) {
  _internal_set_max_vel_theta(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_theta)
}

// optional float acc_lim_x = 5;
inline bool Robot::_internal_has_acc_lim_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Robot::has_acc_lim_x() const {
  return _internal_has_acc_lim_x();
}
inline void Robot::clear_acc_lim_x() {
  _impl_.acc_lim_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Robot::_internal_acc_lim_x() const {
  return _impl_.acc_lim_x_;
}
inline float Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_x)
  return _internal_acc_lim_x();
}
inline void Robot::_internal_set_acc_lim_x(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.acc_lim_x_ = value;
}
inline void Robot::set_acc_lim_x(float value) {
  _internal_set_acc_lim_x(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_x)
}

// optional float acc_lim_y = 6;
inline bool Robot::_internal_has_acc_lim_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Robot::has_acc_lim_y() const {
  return _internal_has_acc_lim_y();
}
inline void Robot::clear_acc_lim_y() {
  _impl_.acc_lim_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Robot::_internal_acc_lim_y() const {
  return _impl_.acc_lim_y_;
}
inline float Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_y)
  return _internal_acc_lim_y();
}
inline void Robot::_internal_set_acc_lim_y(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.acc_lim_y_ = value;
}
inline void Robot::set_acc_lim_y(float value) {
  _internal_set_acc_lim_y(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_y)
}

// optional float acc_lim_theta = 7;
inline bool Robot::_internal_has_acc_lim_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Robot::has_acc_lim_theta() const {
  return _internal_has_acc_lim_theta();
}
inline void Robot::clear_acc_lim_theta() {
  _impl_.acc_lim_theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Robot::_internal_acc_lim_theta() const {
  return _impl_.acc_lim_theta_;
}
inline float Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_theta)
  return _internal_acc_lim_theta();
}
inline void Robot::_internal_set_acc_lim_theta(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.acc_lim_theta_ = value;
}
inline void Robot::set_acc_lim_theta(float value) {
  _internal_set_acc_lim_theta(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_theta)
}

// optional float min_turning_radius = 8;
inline bool Robot::_internal_has_min_turning_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Robot::has_min_turning_radius() const {
  return _internal_has_min_turning_radius();
}
inline void Robot::clear_min_turning_radius() {
  _impl_.min_turning_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Robot::_internal_min_turning_radius() const {
  return _impl_.min_turning_radius_;
}
inline float Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.min_turning_radius)
  return _internal_min_turning_radius();
}
inline void Robot::_internal_set_min_turning_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.min_turning_radius_ = value;
}
inline void Robot::set_min_turning_radius(float value) {
  _internal_set_min_turning_radius(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.min_turning_radius)
}

// optional float wheelbase = 9;
inline bool Robot::_internal_has_wheelbase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Robot::has_wheelbase() const {
  return _internal_has_wheelbase();
}
inline void Robot::clear_wheelbase() {
  _impl_.wheelbase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Robot::_internal_wheelbase() const {
  return _impl_.wheelbase_;
}
inline float Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.wheelbase)
  return _internal_wheelbase();
}
inline void Robot::_internal_set_wheelbase(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.wheelbase_ = value;
}
inline void Robot::set_wheelbase(float value) {
  _internal_set_wheelbase(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
inline bool Robot::_internal_has_cmd_angle_instead_rotvel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Robot::has_cmd_angle_instead_rotvel() const {
  return _internal_has_cmd_angle_instead_rotvel();
}
inline void Robot::clear_cmd_angle_instead_rotvel() {
  _impl_.cmd_angle_instead_rotvel_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool Robot::_internal_cmd_angle_instead_rotvel() const {
  return _impl_.cmd_angle_instead_rotvel_;
}
inline bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
  return _internal_cmd_angle_instead_rotvel();
}
inline void Robot::_internal_set_cmd_angle_instead_rotvel(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.cmd_angle_instead_rotvel_ = value;
}
inline void Robot::set_cmd_angle_instead_rotvel(bool value) {
  _internal_set_cmd_angle_instead_rotvel(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
}

// -------------------------------------------------------------------

// GoalTolerance

// optional float xy_goal_tolerance = 1;
inline bool GoalTolerance::_internal_has_xy_goal_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GoalTolerance::has_xy_goal_tolerance() const {
  return _internal_has_xy_goal_tolerance();
}
inline void GoalTolerance::clear_xy_goal_tolerance() {
  _impl_.xy_goal_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float GoalTolerance::_internal_xy_goal_tolerance() const {
  return _impl_.xy_goal_tolerance_;
}
inline float GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
  return _internal_xy_goal_tolerance();
}
inline void GoalTolerance::_internal_set_xy_goal_tolerance(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xy_goal_tolerance_ = value;
}
inline void GoalTolerance::set_xy_goal_tolerance(float value) {
  _internal_set_xy_goal_tolerance(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
}

// optional float yaw_goal_tolerance = 2;
inline bool GoalTolerance::_internal_has_yaw_goal_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GoalTolerance::has_yaw_goal_tolerance() const {
  return _internal_has_yaw_goal_tolerance();
}
inline void GoalTolerance::clear_yaw_goal_tolerance() {
  _impl_.yaw_goal_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float GoalTolerance::_internal_yaw_goal_tolerance() const {
  return _impl_.yaw_goal_tolerance_;
}
inline float GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
  return _internal_yaw_goal_tolerance();
}
inline void GoalTolerance::_internal_set_yaw_goal_tolerance(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.yaw_goal_tolerance_ = value;
}
inline void GoalTolerance::set_yaw_goal_tolerance(float value) {
  _internal_set_yaw_goal_tolerance(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
}

// optional bool free_goal_vel = 3;
inline bool GoalTolerance::_internal_has_free_goal_vel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GoalTolerance::has_free_goal_vel() const {
  return _internal_has_free_goal_vel();
}
inline void GoalTolerance::clear_free_goal_vel() {
  _impl_.free_goal_vel_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool GoalTolerance::_internal_free_goal_vel() const {
  return _impl_.free_goal_vel_;
}
inline bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.free_goal_vel)
  return _internal_free_goal_vel();
}
inline void GoalTolerance::_internal_set_free_goal_vel(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.free_goal_vel_ = value;
}
inline void GoalTolerance::set_free_goal_vel(bool value) {
  _internal_set_free_goal_vel(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.free_goal_vel)
}

// -------------------------------------------------------------------

// Obstacles

// optional float min_obstacle_dist = 1;
inline bool Obstacles::_internal_has_min_obstacle_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Obstacles::has_min_obstacle_dist() const {
  return _internal_has_min_obstacle_dist();
}
inline void Obstacles::clear_min_obstacle_dist() {
  _impl_.min_obstacle_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Obstacles::_internal_min_obstacle_dist() const {
  return _impl_.min_obstacle_dist_;
}
inline float Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.min_obstacle_dist)
  return _internal_min_obstacle_dist();
}
inline void Obstacles::_internal_set_min_obstacle_dist(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_obstacle_dist_ = value;
}
inline void Obstacles::set_min_obstacle_dist(float value) {
  _internal_set_min_obstacle_dist(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.min_obstacle_dist)
}

// optional float inflation_dist = 2;
inline bool Obstacles::_internal_has_inflation_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Obstacles::has_inflation_dist() const {
  return _internal_has_inflation_dist();
}
inline void Obstacles::clear_inflation_dist() {
  _impl_.inflation_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Obstacles::_internal_inflation_dist() const {
  return _impl_.inflation_dist_;
}
inline float Obstacles::inflation_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.inflation_dist)
  return _internal_inflation_dist();
}
inline void Obstacles::_internal_set_inflation_dist(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.inflation_dist_ = value;
}
inline void Obstacles::set_inflation_dist(float value) {
  _internal_set_inflation_dist(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.inflation_dist)
}

// optional bool include_costmap_obstacles = 3;
inline bool Obstacles::_internal_has_include_costmap_obstacles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Obstacles::has_include_costmap_obstacles() const {
  return _internal_has_include_costmap_obstacles();
}
inline void Obstacles::clear_include_costmap_obstacles() {
  _impl_.include_costmap_obstacles_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Obstacles::_internal_include_costmap_obstacles() const {
  return _impl_.include_costmap_obstacles_;
}
inline bool Obstacles::include_costmap_obstacles() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.include_costmap_obstacles)
  return _internal_include_costmap_obstacles();
}
inline void Obstacles::_internal_set_include_costmap_obstacles(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.include_costmap_obstacles_ = value;
}
inline void Obstacles::set_include_costmap_obstacles(bool value) {
  _internal_set_include_costmap_obstacles(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.include_costmap_obstacles)
}

// optional float costmap_obstacles_behind_robot_dist = 4;
inline bool Obstacles::_internal_has_costmap_obstacles_behind_robot_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return _internal_has_costmap_obstacles_behind_robot_dist();
}
inline void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  _impl_.costmap_obstacles_behind_robot_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Obstacles::_internal_costmap_obstacles_behind_robot_dist() const {
  return _impl_.costmap_obstacles_behind_robot_dist_;
}
inline float Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
  return _internal_costmap_obstacles_behind_robot_dist();
}
inline void Obstacles::_internal_set_costmap_obstacles_behind_robot_dist(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.costmap_obstacles_behind_robot_dist_ = value;
}
inline void Obstacles::set_costmap_obstacles_behind_robot_dist(float value) {
  _internal_set_costmap_obstacles_behind_robot_dist(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional float obstacle_poses_affected = 5;
inline bool Obstacles::_internal_has_obstacle_poses_affected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Obstacles::has_obstacle_poses_affected() const {
  return _internal_has_obstacle_poses_affected();
}
inline void Obstacles::clear_obstacle_poses_affected() {
  _impl_.obstacle_poses_affected_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Obstacles::_internal_obstacle_poses_affected() const {
  return _impl_.obstacle_poses_affected_;
}
inline float Obstacles::obstacle_poses_affected() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_poses_affected)
  return _internal_obstacle_poses_affected();
}
inline void Obstacles::_internal_set_obstacle_poses_affected(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.obstacle_poses_affected_ = value;
}
inline void Obstacles::set_obstacle_poses_affected(float value) {
  _internal_set_obstacle_poses_affected(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_poses_affected)
}

// optional bool legacy_obstacle_association = 6;
inline bool Obstacles::_internal_has_legacy_obstacle_association() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Obstacles::has_legacy_obstacle_association() const {
  return _internal_has_legacy_obstacle_association();
}
inline void Obstacles::clear_legacy_obstacle_association() {
  _impl_.legacy_obstacle_association_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Obstacles::_internal_legacy_obstacle_association() const {
  return _impl_.legacy_obstacle_association_;
}
inline bool Obstacles::legacy_obstacle_association() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.legacy_obstacle_association)
  return _internal_legacy_obstacle_association();
}
inline void Obstacles::_internal_set_legacy_obstacle_association(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.legacy_obstacle_association_ = value;
}
inline void Obstacles::set_legacy_obstacle_association(bool value) {
  _internal_set_legacy_obstacle_association(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.legacy_obstacle_association)
}

// optional float obstacle_association_cutoff_factor = 7;
inline bool Obstacles::_internal_has_obstacle_association_cutoff_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return _internal_has_obstacle_association_cutoff_factor();
}
inline void Obstacles::clear_obstacle_association_cutoff_factor() {
  _impl_.obstacle_association_cutoff_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Obstacles::_internal_obstacle_association_cutoff_factor() const {
  return _impl_.obstacle_association_cutoff_factor_;
}
inline float Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
  return _internal_obstacle_association_cutoff_factor();
}
inline void Obstacles::_internal_set_obstacle_association_cutoff_factor(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.obstacle_association_cutoff_factor_ = value;
}
inline void Obstacles::set_obstacle_association_cutoff_factor(float value) {
  _internal_set_obstacle_association_cutoff_factor(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
}

// optional float obstacle_association_force_inclusion_factor = 8;
inline bool Obstacles::_internal_has_obstacle_association_force_inclusion_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return _internal_has_obstacle_association_force_inclusion_factor();
}
inline void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  _impl_.obstacle_association_force_inclusion_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Obstacles::_internal_obstacle_association_force_inclusion_factor() const {
  return _impl_.obstacle_association_force_inclusion_factor_;
}
inline float Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
  return _internal_obstacle_association_force_inclusion_factor();
}
inline void Obstacles::_internal_set_obstacle_association_force_inclusion_factor(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.obstacle_association_force_inclusion_factor_ = value;
}
inline void Obstacles::set_obstacle_association_force_inclusion_factor(float value) {
  _internal_set_obstacle_association_force_inclusion_factor(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
}

// optional string costmap_converter_plugin = 9;
inline bool Obstacles::_internal_has_costmap_converter_plugin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Obstacles::has_costmap_converter_plugin() const {
  return _internal_has_costmap_converter_plugin();
}
inline void Obstacles::clear_costmap_converter_plugin() {
  _impl_.costmap_converter_plugin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Obstacles::costmap_converter_plugin() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return _internal_costmap_converter_plugin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Obstacles::set_costmap_converter_plugin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.costmap_converter_plugin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
inline std::string* Obstacles::mutable_costmap_converter_plugin() {
  std::string* _s = _internal_mutable_costmap_converter_plugin();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return _s;
}
inline const std::string& Obstacles::_internal_costmap_converter_plugin() const {
  return _impl_.costmap_converter_plugin_.Get();
}
inline void Obstacles::_internal_set_costmap_converter_plugin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.costmap_converter_plugin_.Set(value, GetArenaForAllocation());
}
inline std::string* Obstacles::_internal_mutable_costmap_converter_plugin() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.costmap_converter_plugin_.Mutable(GetArenaForAllocation());
}
inline std::string* Obstacles::release_costmap_converter_plugin() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Obstacles.costmap_converter_plugin)
  if (!_internal_has_costmap_converter_plugin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.costmap_converter_plugin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.costmap_converter_plugin_.IsDefault()) {
    _impl_.costmap_converter_plugin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Obstacles::set_allocated_costmap_converter_plugin(std::string* costmap_converter_plugin) {
  if (costmap_converter_plugin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.costmap_converter_plugin_.SetAllocated(costmap_converter_plugin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.costmap_converter_plugin_.IsDefault()) {
    _impl_.costmap_converter_plugin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Obstacles.costmap_converter_plugin)
}

// optional bool costmap_converter_spin_thread = 10;
inline bool Obstacles::_internal_has_costmap_converter_spin_thread() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Obstacles::has_costmap_converter_spin_thread() const {
  return _internal_has_costmap_converter_spin_thread();
}
inline void Obstacles::clear_costmap_converter_spin_thread() {
  _impl_.costmap_converter_spin_thread_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Obstacles::_internal_costmap_converter_spin_thread() const {
  return _impl_.costmap_converter_spin_thread_;
}
inline bool Obstacles::costmap_converter_spin_thread() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
  return _internal_costmap_converter_spin_thread();
}
inline void Obstacles::_internal_set_costmap_converter_spin_thread(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.costmap_converter_spin_thread_ = value;
}
inline void Obstacles::set_costmap_converter_spin_thread(bool value) {
  _internal_set_costmap_converter_spin_thread(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
}

// optional float costmap_converter_rate = 11;
inline bool Obstacles::_internal_has_costmap_converter_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Obstacles::has_costmap_converter_rate() const {
  return _internal_has_costmap_converter_rate();
}
inline void Obstacles::clear_costmap_converter_rate() {
  _impl_.costmap_converter_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Obstacles::_internal_costmap_converter_rate() const {
  return _impl_.costmap_converter_rate_;
}
inline float Obstacles::costmap_converter_rate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_rate)
  return _internal_costmap_converter_rate();
}
inline void Obstacles::_internal_set_costmap_converter_rate(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.costmap_converter_rate_ = value;
}
inline void Obstacles::set_costmap_converter_rate(float value) {
  _internal_set_costmap_converter_rate(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_rate)
}

// -------------------------------------------------------------------

// Optimization

// optional int32 no_inner_iterations = 1;
inline bool Optimization::_internal_has_no_inner_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Optimization::has_no_inner_iterations() const {
  return _internal_has_no_inner_iterations();
}
inline void Optimization::clear_no_inner_iterations() {
  _impl_.no_inner_iterations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Optimization::_internal_no_inner_iterations() const {
  return _impl_.no_inner_iterations_;
}
inline int32_t Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_inner_iterations)
  return _internal_no_inner_iterations();
}
inline void Optimization::_internal_set_no_inner_iterations(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.no_inner_iterations_ = value;
}
inline void Optimization::set_no_inner_iterations(int32_t value) {
  _internal_set_no_inner_iterations(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
inline bool Optimization::_internal_has_no_outer_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Optimization::has_no_outer_iterations() const {
  return _internal_has_no_outer_iterations();
}
inline void Optimization::clear_no_outer_iterations() {
  _impl_.no_outer_iterations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Optimization::_internal_no_outer_iterations() const {
  return _impl_.no_outer_iterations_;
}
inline int32_t Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_outer_iterations)
  return _internal_no_outer_iterations();
}
inline void Optimization::_internal_set_no_outer_iterations(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.no_outer_iterations_ = value;
}
inline void Optimization::set_no_outer_iterations(int32_t value) {
  _internal_set_no_outer_iterations(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
inline bool Optimization::_internal_has_optimization_activate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Optimization::has_optimization_activate() const {
  return _internal_has_optimization_activate();
}
inline void Optimization::clear_optimization_activate() {
  _impl_.optimization_activate_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Optimization::_internal_optimization_activate() const {
  return _impl_.optimization_activate_;
}
inline bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_activate)
  return _internal_optimization_activate();
}
inline void Optimization::_internal_set_optimization_activate(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.optimization_activate_ = value;
}
inline void Optimization::set_optimization_activate(bool value) {
  _internal_set_optimization_activate(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
inline bool Optimization::_internal_has_optimization_verbose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Optimization::has_optimization_verbose() const {
  return _internal_has_optimization_verbose();
}
inline void Optimization::clear_optimization_verbose() {
  _impl_.optimization_verbose_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Optimization::_internal_optimization_verbose() const {
  return _impl_.optimization_verbose_;
}
inline bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_verbose)
  return _internal_optimization_verbose();
}
inline void Optimization::_internal_set_optimization_verbose(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.optimization_verbose_ = value;
}
inline void Optimization::set_optimization_verbose(bool value) {
  _internal_set_optimization_verbose(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_verbose)
}

// optional float penalty_epsilon = 5;
inline bool Optimization::_internal_has_penalty_epsilon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Optimization::has_penalty_epsilon() const {
  return _internal_has_penalty_epsilon();
}
inline void Optimization::clear_penalty_epsilon() {
  _impl_.penalty_epsilon_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Optimization::_internal_penalty_epsilon() const {
  return _impl_.penalty_epsilon_;
}
inline float Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.penalty_epsilon)
  return _internal_penalty_epsilon();
}
inline void Optimization::_internal_set_penalty_epsilon(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.penalty_epsilon_ = value;
}
inline void Optimization::set_penalty_epsilon(float value) {
  _internal_set_penalty_epsilon(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.penalty_epsilon)
}

// optional float weight_max_vel_x = 6;
inline bool Optimization::_internal_has_weight_max_vel_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Optimization::has_weight_max_vel_x() const {
  return _internal_has_weight_max_vel_x();
}
inline void Optimization::clear_weight_max_vel_x() {
  _impl_.weight_max_vel_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Optimization::_internal_weight_max_vel_x() const {
  return _impl_.weight_max_vel_x_;
}
inline float Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_x)
  return _internal_weight_max_vel_x();
}
inline void Optimization::_internal_set_weight_max_vel_x(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.weight_max_vel_x_ = value;
}
inline void Optimization::set_weight_max_vel_x(float value) {
  _internal_set_weight_max_vel_x(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_x)
}

// optional float weight_max_vel_y = 7;
inline bool Optimization::_internal_has_weight_max_vel_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Optimization::has_weight_max_vel_y() const {
  return _internal_has_weight_max_vel_y();
}
inline void Optimization::clear_weight_max_vel_y() {
  _impl_.weight_max_vel_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Optimization::_internal_weight_max_vel_y() const {
  return _impl_.weight_max_vel_y_;
}
inline float Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_y)
  return _internal_weight_max_vel_y();
}
inline void Optimization::_internal_set_weight_max_vel_y(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.weight_max_vel_y_ = value;
}
inline void Optimization::set_weight_max_vel_y(float value) {
  _internal_set_weight_max_vel_y(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_y)
}

// optional float weight_max_vel_theta = 8;
inline bool Optimization::_internal_has_weight_max_vel_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Optimization::has_weight_max_vel_theta() const {
  return _internal_has_weight_max_vel_theta();
}
inline void Optimization::clear_weight_max_vel_theta() {
  _impl_.weight_max_vel_theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Optimization::_internal_weight_max_vel_theta() const {
  return _impl_.weight_max_vel_theta_;
}
inline float Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_theta)
  return _internal_weight_max_vel_theta();
}
inline void Optimization::_internal_set_weight_max_vel_theta(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.weight_max_vel_theta_ = value;
}
inline void Optimization::set_weight_max_vel_theta(float value) {
  _internal_set_weight_max_vel_theta(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_theta)
}

// optional float weight_acc_lim_x = 9;
inline bool Optimization::_internal_has_weight_acc_lim_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Optimization::has_weight_acc_lim_x() const {
  return _internal_has_weight_acc_lim_x();
}
inline void Optimization::clear_weight_acc_lim_x() {
  _impl_.weight_acc_lim_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Optimization::_internal_weight_acc_lim_x() const {
  return _impl_.weight_acc_lim_x_;
}
inline float Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_x)
  return _internal_weight_acc_lim_x();
}
inline void Optimization::_internal_set_weight_acc_lim_x(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.weight_acc_lim_x_ = value;
}
inline void Optimization::set_weight_acc_lim_x(float value) {
  _internal_set_weight_acc_lim_x(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_x)
}

// optional float weight_acc_lim_y = 10;
inline bool Optimization::_internal_has_weight_acc_lim_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Optimization::has_weight_acc_lim_y() const {
  return _internal_has_weight_acc_lim_y();
}
inline void Optimization::clear_weight_acc_lim_y() {
  _impl_.weight_acc_lim_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Optimization::_internal_weight_acc_lim_y() const {
  return _impl_.weight_acc_lim_y_;
}
inline float Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_y)
  return _internal_weight_acc_lim_y();
}
inline void Optimization::_internal_set_weight_acc_lim_y(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.weight_acc_lim_y_ = value;
}
inline void Optimization::set_weight_acc_lim_y(float value) {
  _internal_set_weight_acc_lim_y(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_y)
}

// optional float weight_acc_lim_thet = 11;
inline bool Optimization::_internal_has_weight_acc_lim_thet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Optimization::has_weight_acc_lim_thet() const {
  return _internal_has_weight_acc_lim_thet();
}
inline void Optimization::clear_weight_acc_lim_thet() {
  _impl_.weight_acc_lim_thet_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Optimization::_internal_weight_acc_lim_thet() const {
  return _impl_.weight_acc_lim_thet_;
}
inline float Optimization::weight_acc_lim_thet() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_thet)
  return _internal_weight_acc_lim_thet();
}
inline void Optimization::_internal_set_weight_acc_lim_thet(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.weight_acc_lim_thet_ = value;
}
inline void Optimization::set_weight_acc_lim_thet(float value) {
  _internal_set_weight_acc_lim_thet(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_thet)
}

// optional float weight_kinematics_nh = 12;
inline bool Optimization::_internal_has_weight_kinematics_nh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Optimization::has_weight_kinematics_nh() const {
  return _internal_has_weight_kinematics_nh();
}
inline void Optimization::clear_weight_kinematics_nh() {
  _impl_.weight_kinematics_nh_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float Optimization::_internal_weight_kinematics_nh() const {
  return _impl_.weight_kinematics_nh_;
}
inline float Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_nh)
  return _internal_weight_kinematics_nh();
}
inline void Optimization::_internal_set_weight_kinematics_nh(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.weight_kinematics_nh_ = value;
}
inline void Optimization::set_weight_kinematics_nh(float value) {
  _internal_set_weight_kinematics_nh(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_nh)
}

// optional float weight_kinematics_forward_drive = 13;
inline bool Optimization::_internal_has_weight_kinematics_forward_drive() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Optimization::has_weight_kinematics_forward_drive() const {
  return _internal_has_weight_kinematics_forward_drive();
}
inline void Optimization::clear_weight_kinematics_forward_drive() {
  _impl_.weight_kinematics_forward_drive_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float Optimization::_internal_weight_kinematics_forward_drive() const {
  return _impl_.weight_kinematics_forward_drive_;
}
inline float Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
  return _internal_weight_kinematics_forward_drive();
}
inline void Optimization::_internal_set_weight_kinematics_forward_drive(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.weight_kinematics_forward_drive_ = value;
}
inline void Optimization::set_weight_kinematics_forward_drive(float value) {
  _internal_set_weight_kinematics_forward_drive(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
}

// optional float weight_kinematics_turning_radius = 14;
inline bool Optimization::_internal_has_weight_kinematics_turning_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Optimization::has_weight_kinematics_turning_radius() const {
  return _internal_has_weight_kinematics_turning_radius();
}
inline void Optimization::clear_weight_kinematics_turning_radius() {
  _impl_.weight_kinematics_turning_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float Optimization::_internal_weight_kinematics_turning_radius() const {
  return _impl_.weight_kinematics_turning_radius_;
}
inline float Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
  return _internal_weight_kinematics_turning_radius();
}
inline void Optimization::_internal_set_weight_kinematics_turning_radius(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.weight_kinematics_turning_radius_ = value;
}
inline void Optimization::set_weight_kinematics_turning_radius(float value) {
  _internal_set_weight_kinematics_turning_radius(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
}

// optional float weight_optimaltime = 15;
inline bool Optimization::_internal_has_weight_optimaltime() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Optimization::has_weight_optimaltime() const {
  return _internal_has_weight_optimaltime();
}
inline void Optimization::clear_weight_optimaltime() {
  _impl_.weight_optimaltime_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float Optimization::_internal_weight_optimaltime() const {
  return _impl_.weight_optimaltime_;
}
inline float Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_optimaltime)
  return _internal_weight_optimaltime();
}
inline void Optimization::_internal_set_weight_optimaltime(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.weight_optimaltime_ = value;
}
inline void Optimization::set_weight_optimaltime(float value) {
  _internal_set_weight_optimaltime(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_optimaltime)
}

// optional float weight_obstacle = 16;
inline bool Optimization::_internal_has_weight_obstacle() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Optimization::has_weight_obstacle() const {
  return _internal_has_weight_obstacle();
}
inline void Optimization::clear_weight_obstacle() {
  _impl_.weight_obstacle_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float Optimization::_internal_weight_obstacle() const {
  return _impl_.weight_obstacle_;
}
inline float Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_obstacle)
  return _internal_weight_obstacle();
}
inline void Optimization::_internal_set_weight_obstacle(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.weight_obstacle_ = value;
}
inline void Optimization::set_weight_obstacle(float value) {
  _internal_set_weight_obstacle(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_obstacle)
}

// optional float weight_inflation = 17;
inline bool Optimization::_internal_has_weight_inflation() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Optimization::has_weight_inflation() const {
  return _internal_has_weight_inflation();
}
inline void Optimization::clear_weight_inflation() {
  _impl_.weight_inflation_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float Optimization::_internal_weight_inflation() const {
  return _impl_.weight_inflation_;
}
inline float Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_inflation)
  return _internal_weight_inflation();
}
inline void Optimization::_internal_set_weight_inflation(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.weight_inflation_ = value;
}
inline void Optimization::set_weight_inflation(float value) {
  _internal_set_weight_inflation(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_inflation)
}

// optional float weight_dynamic_obstacle = 18;
inline bool Optimization::_internal_has_weight_dynamic_obstacle() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Optimization::has_weight_dynamic_obstacle() const {
  return _internal_has_weight_dynamic_obstacle();
}
inline void Optimization::clear_weight_dynamic_obstacle() {
  _impl_.weight_dynamic_obstacle_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline float Optimization::_internal_weight_dynamic_obstacle() const {
  return _impl_.weight_dynamic_obstacle_;
}
inline float Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_dynamic_obstacle)
  return _internal_weight_dynamic_obstacle();
}
inline void Optimization::_internal_set_weight_dynamic_obstacle(float value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.weight_dynamic_obstacle_ = value;
}
inline void Optimization::set_weight_dynamic_obstacle(float value) {
  _internal_set_weight_dynamic_obstacle(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_dynamic_obstacle)
}

// optional float weight_viapoint = 19;
inline bool Optimization::_internal_has_weight_viapoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Optimization::has_weight_viapoint() const {
  return _internal_has_weight_viapoint();
}
inline void Optimization::clear_weight_viapoint() {
  _impl_.weight_viapoint_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline float Optimization::_internal_weight_viapoint() const {
  return _impl_.weight_viapoint_;
}
inline float Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_viapoint)
  return _internal_weight_viapoint();
}
inline void Optimization::_internal_set_weight_viapoint(float value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.weight_viapoint_ = value;
}
inline void Optimization::set_weight_viapoint(float value) {
  _internal_set_weight_viapoint(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_viapoint)
}

// optional float weight_adapt_factor = 20;
inline bool Optimization::_internal_has_weight_adapt_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Optimization::has_weight_adapt_factor() const {
  return _internal_has_weight_adapt_factor();
}
inline void Optimization::clear_weight_adapt_factor() {
  _impl_.weight_adapt_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline float Optimization::_internal_weight_adapt_factor() const {
  return _impl_.weight_adapt_factor_;
}
inline float Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_adapt_factor)
  return _internal_weight_adapt_factor();
}
inline void Optimization::_internal_set_weight_adapt_factor(float value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.weight_adapt_factor_ = value;
}
inline void Optimization::set_weight_adapt_factor(float value) {
  _internal_set_weight_adapt_factor(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_adapt_factor)
}

// optional float weight_prefer_rotdir = 21;
inline bool Optimization::_internal_has_weight_prefer_rotdir() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Optimization::has_weight_prefer_rotdir() const {
  return _internal_has_weight_prefer_rotdir();
}
inline void Optimization::clear_weight_prefer_rotdir() {
  _impl_.weight_prefer_rotdir_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline float Optimization::_internal_weight_prefer_rotdir() const {
  return _impl_.weight_prefer_rotdir_;
}
inline float Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_prefer_rotdir)
  return _internal_weight_prefer_rotdir();
}
inline void Optimization::_internal_set_weight_prefer_rotdir(float value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.weight_prefer_rotdir_ = value;
}
inline void Optimization::set_weight_prefer_rotdir(float value) {
  _internal_set_weight_prefer_rotdir(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_prefer_rotdir)
}

// optional float weight_acc_lim_theta = 22;
inline bool Optimization::_internal_has_weight_acc_lim_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Optimization::has_weight_acc_lim_theta() const {
  return _internal_has_weight_acc_lim_theta();
}
inline void Optimization::clear_weight_acc_lim_theta() {
  _impl_.weight_acc_lim_theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline float Optimization::_internal_weight_acc_lim_theta() const {
  return _impl_.weight_acc_lim_theta_;
}
inline float Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_theta)
  return _internal_weight_acc_lim_theta();
}
inline void Optimization::_internal_set_weight_acc_lim_theta(float value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.weight_acc_lim_theta_ = value;
}
inline void Optimization::set_weight_acc_lim_theta(float value) {
  _internal_set_weight_acc_lim_theta(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_theta)
}

// -------------------------------------------------------------------

// HomotopyClassPlanner

// optional bool enable_homotopy_class_planning = 1;
inline bool HomotopyClassPlanner::_internal_has_enable_homotopy_class_planning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_enable_homotopy_class_planning() const {
  return _internal_has_enable_homotopy_class_planning();
}
inline void HomotopyClassPlanner::clear_enable_homotopy_class_planning() {
  _impl_.enable_homotopy_class_planning_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool HomotopyClassPlanner::_internal_enable_homotopy_class_planning() const {
  return _impl_.enable_homotopy_class_planning_;
}
inline bool HomotopyClassPlanner::enable_homotopy_class_planning() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
  return _internal_enable_homotopy_class_planning();
}
inline void HomotopyClassPlanner::_internal_set_enable_homotopy_class_planning(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_homotopy_class_planning_ = value;
}
inline void HomotopyClassPlanner::set_enable_homotopy_class_planning(bool value) {
  _internal_set_enable_homotopy_class_planning(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
}

// optional bool enable_multithreading = 2;
inline bool HomotopyClassPlanner::_internal_has_enable_multithreading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_enable_multithreading() const {
  return _internal_has_enable_multithreading();
}
inline void HomotopyClassPlanner::clear_enable_multithreading() {
  _impl_.enable_multithreading_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool HomotopyClassPlanner::_internal_enable_multithreading() const {
  return _impl_.enable_multithreading_;
}
inline bool HomotopyClassPlanner::enable_multithreading() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
  return _internal_enable_multithreading();
}
inline void HomotopyClassPlanner::_internal_set_enable_multithreading(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enable_multithreading_ = value;
}
inline void HomotopyClassPlanner::set_enable_multithreading(bool value) {
  _internal_set_enable_multithreading(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
}

// optional bool simple_exploration = 3;
inline bool HomotopyClassPlanner::_internal_has_simple_exploration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_simple_exploration() const {
  return _internal_has_simple_exploration();
}
inline void HomotopyClassPlanner::clear_simple_exploration() {
  _impl_.simple_exploration_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool HomotopyClassPlanner::_internal_simple_exploration() const {
  return _impl_.simple_exploration_;
}
inline bool HomotopyClassPlanner::simple_exploration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
  return _internal_simple_exploration();
}
inline void HomotopyClassPlanner::_internal_set_simple_exploration(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.simple_exploration_ = value;
}
inline void HomotopyClassPlanner::set_simple_exploration(bool value) {
  _internal_set_simple_exploration(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
}

// optional int32 max_number_classes = 4;
inline bool HomotopyClassPlanner::_internal_has_max_number_classes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_max_number_classes() const {
  return _internal_has_max_number_classes();
}
inline void HomotopyClassPlanner::clear_max_number_classes() {
  _impl_.max_number_classes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t HomotopyClassPlanner::_internal_max_number_classes() const {
  return _impl_.max_number_classes_;
}
inline int32_t HomotopyClassPlanner::max_number_classes() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
  return _internal_max_number_classes();
}
inline void HomotopyClassPlanner::_internal_set_max_number_classes(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.max_number_classes_ = value;
}
inline void HomotopyClassPlanner::set_max_number_classes(int32_t value) {
  _internal_set_max_number_classes(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
}

// optional float selection_obst_cost_scale = 5;
inline bool HomotopyClassPlanner::_internal_has_selection_obst_cost_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_selection_obst_cost_scale() const {
  return _internal_has_selection_obst_cost_scale();
}
inline void HomotopyClassPlanner::clear_selection_obst_cost_scale() {
  _impl_.selection_obst_cost_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float HomotopyClassPlanner::_internal_selection_obst_cost_scale() const {
  return _impl_.selection_obst_cost_scale_;
}
inline float HomotopyClassPlanner::selection_obst_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
  return _internal_selection_obst_cost_scale();
}
inline void HomotopyClassPlanner::_internal_set_selection_obst_cost_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.selection_obst_cost_scale_ = value;
}
inline void HomotopyClassPlanner::set_selection_obst_cost_scale(float value) {
  _internal_set_selection_obst_cost_scale(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
}

// optional float selection_prefer_initial_plan = 6;
inline bool HomotopyClassPlanner::_internal_has_selection_prefer_initial_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_selection_prefer_initial_plan() const {
  return _internal_has_selection_prefer_initial_plan();
}
inline void HomotopyClassPlanner::clear_selection_prefer_initial_plan() {
  _impl_.selection_prefer_initial_plan_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float HomotopyClassPlanner::_internal_selection_prefer_initial_plan() const {
  return _impl_.selection_prefer_initial_plan_;
}
inline float HomotopyClassPlanner::selection_prefer_initial_plan() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
  return _internal_selection_prefer_initial_plan();
}
inline void HomotopyClassPlanner::_internal_set_selection_prefer_initial_plan(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.selection_prefer_initial_plan_ = value;
}
inline void HomotopyClassPlanner::set_selection_prefer_initial_plan(float value) {
  _internal_set_selection_prefer_initial_plan(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
}

// optional float selection_viapoint_cost_scale = 7;
inline bool HomotopyClassPlanner::_internal_has_selection_viapoint_cost_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_selection_viapoint_cost_scale() const {
  return _internal_has_selection_viapoint_cost_scale();
}
inline void HomotopyClassPlanner::clear_selection_viapoint_cost_scale() {
  _impl_.selection_viapoint_cost_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float HomotopyClassPlanner::_internal_selection_viapoint_cost_scale() const {
  return _impl_.selection_viapoint_cost_scale_;
}
inline float HomotopyClassPlanner::selection_viapoint_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
  return _internal_selection_viapoint_cost_scale();
}
inline void HomotopyClassPlanner::_internal_set_selection_viapoint_cost_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.selection_viapoint_cost_scale_ = value;
}
inline void HomotopyClassPlanner::set_selection_viapoint_cost_scale(float value) {
  _internal_set_selection_viapoint_cost_scale(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
}

// optional float selection_cost_hysteresis = 8;
inline bool HomotopyClassPlanner::_internal_has_selection_cost_hysteresis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_selection_cost_hysteresis() const {
  return _internal_has_selection_cost_hysteresis();
}
inline void HomotopyClassPlanner::clear_selection_cost_hysteresis() {
  _impl_.selection_cost_hysteresis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float HomotopyClassPlanner::_internal_selection_cost_hysteresis() const {
  return _impl_.selection_cost_hysteresis_;
}
inline float HomotopyClassPlanner::selection_cost_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
  return _internal_selection_cost_hysteresis();
}
inline void HomotopyClassPlanner::_internal_set_selection_cost_hysteresis(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.selection_cost_hysteresis_ = value;
}
inline void HomotopyClassPlanner::set_selection_cost_hysteresis(float value) {
  _internal_set_selection_cost_hysteresis(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
}

// optional bool selection_alternative_time_cost = 9;
inline bool HomotopyClassPlanner::_internal_has_selection_alternative_time_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_selection_alternative_time_cost() const {
  return _internal_has_selection_alternative_time_cost();
}
inline void HomotopyClassPlanner::clear_selection_alternative_time_cost() {
  _impl_.selection_alternative_time_cost_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool HomotopyClassPlanner::_internal_selection_alternative_time_cost() const {
  return _impl_.selection_alternative_time_cost_;
}
inline bool HomotopyClassPlanner::selection_alternative_time_cost() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
  return _internal_selection_alternative_time_cost();
}
inline void HomotopyClassPlanner::_internal_set_selection_alternative_time_cost(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_alternative_time_cost_ = value;
}
inline void HomotopyClassPlanner::set_selection_alternative_time_cost(bool value) {
  _internal_set_selection_alternative_time_cost(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
}

// optional int32 roadmap_graph_no_samples = 10;
inline bool HomotopyClassPlanner::_internal_has_roadmap_graph_no_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_roadmap_graph_no_samples() const {
  return _internal_has_roadmap_graph_no_samples();
}
inline void HomotopyClassPlanner::clear_roadmap_graph_no_samples() {
  _impl_.roadmap_graph_no_samples_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t HomotopyClassPlanner::_internal_roadmap_graph_no_samples() const {
  return _impl_.roadmap_graph_no_samples_;
}
inline int32_t HomotopyClassPlanner::roadmap_graph_no_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
  return _internal_roadmap_graph_no_samples();
}
inline void HomotopyClassPlanner::_internal_set_roadmap_graph_no_samples(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.roadmap_graph_no_samples_ = value;
}
inline void HomotopyClassPlanner::set_roadmap_graph_no_samples(int32_t value) {
  _internal_set_roadmap_graph_no_samples(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
}

// optional int32 roadmap_graph_area_width = 11;
inline bool HomotopyClassPlanner::_internal_has_roadmap_graph_area_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_roadmap_graph_area_width() const {
  return _internal_has_roadmap_graph_area_width();
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_width() {
  _impl_.roadmap_graph_area_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t HomotopyClassPlanner::_internal_roadmap_graph_area_width() const {
  return _impl_.roadmap_graph_area_width_;
}
inline int32_t HomotopyClassPlanner::roadmap_graph_area_width() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
  return _internal_roadmap_graph_area_width();
}
inline void HomotopyClassPlanner::_internal_set_roadmap_graph_area_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.roadmap_graph_area_width_ = value;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_width(int32_t value) {
  _internal_set_roadmap_graph_area_width(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
}

// optional float roadmap_graph_area_length_scale = 12;
inline bool HomotopyClassPlanner::_internal_has_roadmap_graph_area_length_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_roadmap_graph_area_length_scale() const {
  return _internal_has_roadmap_graph_area_length_scale();
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_length_scale() {
  _impl_.roadmap_graph_area_length_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float HomotopyClassPlanner::_internal_roadmap_graph_area_length_scale() const {
  return _impl_.roadmap_graph_area_length_scale_;
}
inline float HomotopyClassPlanner::roadmap_graph_area_length_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
  return _internal_roadmap_graph_area_length_scale();
}
inline void HomotopyClassPlanner::_internal_set_roadmap_graph_area_length_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.roadmap_graph_area_length_scale_ = value;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_length_scale(float value) {
  _internal_set_roadmap_graph_area_length_scale(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
}

// optional float h_signature_prescaler = 13;
inline bool HomotopyClassPlanner::_internal_has_h_signature_prescaler() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_h_signature_prescaler() const {
  return _internal_has_h_signature_prescaler();
}
inline void HomotopyClassPlanner::clear_h_signature_prescaler() {
  _impl_.h_signature_prescaler_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float HomotopyClassPlanner::_internal_h_signature_prescaler() const {
  return _impl_.h_signature_prescaler_;
}
inline float HomotopyClassPlanner::h_signature_prescaler() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
  return _internal_h_signature_prescaler();
}
inline void HomotopyClassPlanner::_internal_set_h_signature_prescaler(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.h_signature_prescaler_ = value;
}
inline void HomotopyClassPlanner::set_h_signature_prescaler(float value) {
  _internal_set_h_signature_prescaler(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
}

// optional float h_signature_threshold = 14;
inline bool HomotopyClassPlanner::_internal_has_h_signature_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_h_signature_threshold() const {
  return _internal_has_h_signature_threshold();
}
inline void HomotopyClassPlanner::clear_h_signature_threshold() {
  _impl_.h_signature_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float HomotopyClassPlanner::_internal_h_signature_threshold() const {
  return _impl_.h_signature_threshold_;
}
inline float HomotopyClassPlanner::h_signature_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
  return _internal_h_signature_threshold();
}
inline void HomotopyClassPlanner::_internal_set_h_signature_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.h_signature_threshold_ = value;
}
inline void HomotopyClassPlanner::set_h_signature_threshold(float value) {
  _internal_set_h_signature_threshold(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
}

// optional float obstacle_keypoint_offset = 15;
inline bool HomotopyClassPlanner::_internal_has_obstacle_keypoint_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_obstacle_keypoint_offset() const {
  return _internal_has_obstacle_keypoint_offset();
}
inline void HomotopyClassPlanner::clear_obstacle_keypoint_offset() {
  _impl_.obstacle_keypoint_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float HomotopyClassPlanner::_internal_obstacle_keypoint_offset() const {
  return _impl_.obstacle_keypoint_offset_;
}
inline float HomotopyClassPlanner::obstacle_keypoint_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
  return _internal_obstacle_keypoint_offset();
}
inline void HomotopyClassPlanner::_internal_set_obstacle_keypoint_offset(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.obstacle_keypoint_offset_ = value;
}
inline void HomotopyClassPlanner::set_obstacle_keypoint_offset(float value) {
  _internal_set_obstacle_keypoint_offset(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
}

// optional float obstacle_heading_threshold = 16;
inline bool HomotopyClassPlanner::_internal_has_obstacle_heading_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_obstacle_heading_threshold() const {
  return _internal_has_obstacle_heading_threshold();
}
inline void HomotopyClassPlanner::clear_obstacle_heading_threshold() {
  _impl_.obstacle_heading_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float HomotopyClassPlanner::_internal_obstacle_heading_threshold() const {
  return _impl_.obstacle_heading_threshold_;
}
inline float HomotopyClassPlanner::obstacle_heading_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
  return _internal_obstacle_heading_threshold();
}
inline void HomotopyClassPlanner::_internal_set_obstacle_heading_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.obstacle_heading_threshold_ = value;
}
inline void HomotopyClassPlanner::set_obstacle_heading_threshold(float value) {
  _internal_set_obstacle_heading_threshold(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
}

// optional bool viapoints_all_candidates = 17;
inline bool HomotopyClassPlanner::_internal_has_viapoints_all_candidates() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_viapoints_all_candidates() const {
  return _internal_has_viapoints_all_candidates();
}
inline void HomotopyClassPlanner::clear_viapoints_all_candidates() {
  _impl_.viapoints_all_candidates_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool HomotopyClassPlanner::_internal_viapoints_all_candidates() const {
  return _impl_.viapoints_all_candidates_;
}
inline bool HomotopyClassPlanner::viapoints_all_candidates() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
  return _internal_viapoints_all_candidates();
}
inline void HomotopyClassPlanner::_internal_set_viapoints_all_candidates(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.viapoints_all_candidates_ = value;
}
inline void HomotopyClassPlanner::set_viapoints_all_candidates(bool value) {
  _internal_set_viapoints_all_candidates(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
}

// optional bool visualize_hc_graph = 18;
inline bool HomotopyClassPlanner::_internal_has_visualize_hc_graph() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool HomotopyClassPlanner::has_visualize_hc_graph() const {
  return _internal_has_visualize_hc_graph();
}
inline void HomotopyClassPlanner::clear_visualize_hc_graph() {
  _impl_.visualize_hc_graph_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool HomotopyClassPlanner::_internal_visualize_hc_graph() const {
  return _impl_.visualize_hc_graph_;
}
inline bool HomotopyClassPlanner::visualize_hc_graph() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
  return _internal_visualize_hc_graph();
}
inline void HomotopyClassPlanner::_internal_set_visualize_hc_graph(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.visualize_hc_graph_ = value;
}
inline void HomotopyClassPlanner::set_visualize_hc_graph(bool value) {
  _internal_set_visualize_hc_graph(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
}

// -------------------------------------------------------------------

// Recovery

// optional bool shrink_horizon_min_duration = 1;
inline bool Recovery::_internal_has_shrink_horizon_min_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Recovery::has_shrink_horizon_min_duration() const {
  return _internal_has_shrink_horizon_min_duration();
}
inline void Recovery::clear_shrink_horizon_min_duration() {
  _impl_.shrink_horizon_min_duration_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Recovery::_internal_shrink_horizon_min_duration() const {
  return _impl_.shrink_horizon_min_duration_;
}
inline bool Recovery::shrink_horizon_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_min_duration)
  return _internal_shrink_horizon_min_duration();
}
inline void Recovery::_internal_set_shrink_horizon_min_duration(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.shrink_horizon_min_duration_ = value;
}
inline void Recovery::set_shrink_horizon_min_duration(bool value) {
  _internal_set_shrink_horizon_min_duration(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_min_duration)
}

// optional bool oscillation_recovery = 2;
inline bool Recovery::_internal_has_oscillation_recovery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Recovery::has_oscillation_recovery() const {
  return _internal_has_oscillation_recovery();
}
inline void Recovery::clear_oscillation_recovery() {
  _impl_.oscillation_recovery_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Recovery::_internal_oscillation_recovery() const {
  return _impl_.oscillation_recovery_;
}
inline bool Recovery::oscillation_recovery() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery)
  return _internal_oscillation_recovery();
}
inline void Recovery::_internal_set_oscillation_recovery(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.oscillation_recovery_ = value;
}
inline void Recovery::set_oscillation_recovery(bool value) {
  _internal_set_oscillation_recovery(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery)
}

// optional bool shrink_horizon_backup = 3;
inline bool Recovery::_internal_has_shrink_horizon_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Recovery::has_shrink_horizon_backup() const {
  return _internal_has_shrink_horizon_backup();
}
inline void Recovery::clear_shrink_horizon_backup() {
  _impl_.shrink_horizon_backup_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Recovery::_internal_shrink_horizon_backup() const {
  return _impl_.shrink_horizon_backup_;
}
inline bool Recovery::shrink_horizon_backup() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_backup)
  return _internal_shrink_horizon_backup();
}
inline void Recovery::_internal_set_shrink_horizon_backup(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shrink_horizon_backup_ = value;
}
inline void Recovery::set_shrink_horizon_backup(bool value) {
  _internal_set_shrink_horizon_backup(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_backup)
}

// optional double oscillation_v_eps = 4;
inline bool Recovery::_internal_has_oscillation_v_eps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Recovery::has_oscillation_v_eps() const {
  return _internal_has_oscillation_v_eps();
}
inline void Recovery::clear_oscillation_v_eps() {
  _impl_.oscillation_v_eps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Recovery::_internal_oscillation_v_eps() const {
  return _impl_.oscillation_v_eps_;
}
inline double Recovery::oscillation_v_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_v_eps)
  return _internal_oscillation_v_eps();
}
inline void Recovery::_internal_set_oscillation_v_eps(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.oscillation_v_eps_ = value;
}
inline void Recovery::set_oscillation_v_eps(double value) {
  _internal_set_oscillation_v_eps(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_v_eps)
}

// optional double oscillation_omega_eps = 5;
inline bool Recovery::_internal_has_oscillation_omega_eps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Recovery::has_oscillation_omega_eps() const {
  return _internal_has_oscillation_omega_eps();
}
inline void Recovery::clear_oscillation_omega_eps() {
  _impl_.oscillation_omega_eps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Recovery::_internal_oscillation_omega_eps() const {
  return _impl_.oscillation_omega_eps_;
}
inline double Recovery::oscillation_omega_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_omega_eps)
  return _internal_oscillation_omega_eps();
}
inline void Recovery::_internal_set_oscillation_omega_eps(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.oscillation_omega_eps_ = value;
}
inline void Recovery::set_oscillation_omega_eps(double value) {
  _internal_set_oscillation_omega_eps(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_omega_eps)
}

// optional double oscillation_recovery_min_duration = 6;
inline bool Recovery::_internal_has_oscillation_recovery_min_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Recovery::has_oscillation_recovery_min_duration() const {
  return _internal_has_oscillation_recovery_min_duration();
}
inline void Recovery::clear_oscillation_recovery_min_duration() {
  _impl_.oscillation_recovery_min_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Recovery::_internal_oscillation_recovery_min_duration() const {
  return _impl_.oscillation_recovery_min_duration_;
}
inline double Recovery::oscillation_recovery_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
  return _internal_oscillation_recovery_min_duration();
}
inline void Recovery::_internal_set_oscillation_recovery_min_duration(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oscillation_recovery_min_duration_ = value;
}
inline void Recovery::set_oscillation_recovery_min_duration(double value) {
  _internal_set_oscillation_recovery_min_duration(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
}

// optional double oscillation_filter_duration = 7;
inline bool Recovery::_internal_has_oscillation_filter_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Recovery::has_oscillation_filter_duration() const {
  return _internal_has_oscillation_filter_duration();
}
inline void Recovery::clear_oscillation_filter_duration() {
  _impl_.oscillation_filter_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Recovery::_internal_oscillation_filter_duration() const {
  return _impl_.oscillation_filter_duration_;
}
inline double Recovery::oscillation_filter_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_filter_duration)
  return _internal_oscillation_filter_duration();
}
inline void Recovery::_internal_set_oscillation_filter_duration(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.oscillation_filter_duration_ = value;
}
inline void Recovery::set_oscillation_filter_duration(double value) {
  _internal_set_oscillation_filter_duration(value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_filter_duration)
}

// -------------------------------------------------------------------

// Config

// optional .roborts_local_planner.FrameID opt_frame = 1;
inline bool Config::_internal_has_opt_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opt_frame_ != nullptr);
  return value;
}
inline bool Config::has_opt_frame() const {
  return _internal_has_opt_frame();
}
inline void Config::clear_opt_frame() {
  if (_impl_.opt_frame_ != nullptr) _impl_.opt_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::roborts_local_planner::FrameID& Config::_internal_opt_frame() const {
  const ::roborts_local_planner::FrameID* p = _impl_.opt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::FrameID&>(
      ::roborts_local_planner::_FrameID_default_instance_);
}
inline const ::roborts_local_planner::FrameID& Config::opt_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.opt_frame)
  return _internal_opt_frame();
}
inline void Config::unsafe_arena_set_allocated_opt_frame(
    ::roborts_local_planner::FrameID* opt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opt_frame_);
  }
  _impl_.opt_frame_ = opt_frame;
  if (opt_frame) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.opt_frame)
}
inline ::roborts_local_planner::FrameID* Config::release_opt_frame() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::roborts_local_planner::FrameID* temp = _impl_.opt_frame_;
  _impl_.opt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::FrameID* Config::unsafe_arena_release_opt_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.opt_frame)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::roborts_local_planner::FrameID* temp = _impl_.opt_frame_;
  _impl_.opt_frame_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::FrameID* Config::_internal_mutable_opt_frame() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.opt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::FrameID>(GetArenaForAllocation());
    _impl_.opt_frame_ = p;
  }
  return _impl_.opt_frame_;
}
inline ::roborts_local_planner::FrameID* Config::mutable_opt_frame() {
  ::roborts_local_planner::FrameID* _msg = _internal_mutable_opt_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.opt_frame)
  return _msg;
}
inline void Config::set_allocated_opt_frame(::roborts_local_planner::FrameID* opt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opt_frame_;
  }
  if (opt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opt_frame);
    if (message_arena != submessage_arena) {
      opt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opt_frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.opt_frame_ = opt_frame;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.opt_frame)
}

// optional .roborts_local_planner.Trajectory trajectory_opt = 2;
inline bool Config::_internal_has_trajectory_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trajectory_opt_ != nullptr);
  return value;
}
inline bool Config::has_trajectory_opt() const {
  return _internal_has_trajectory_opt();
}
inline void Config::clear_trajectory_opt() {
  if (_impl_.trajectory_opt_ != nullptr) _impl_.trajectory_opt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::roborts_local_planner::Trajectory& Config::_internal_trajectory_opt() const {
  const ::roborts_local_planner::Trajectory* p = _impl_.trajectory_opt_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::Trajectory&>(
      ::roborts_local_planner::_Trajectory_default_instance_);
}
inline const ::roborts_local_planner::Trajectory& Config::trajectory_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.trajectory_opt)
  return _internal_trajectory_opt();
}
inline void Config::unsafe_arena_set_allocated_trajectory_opt(
    ::roborts_local_planner::Trajectory* trajectory_opt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trajectory_opt_);
  }
  _impl_.trajectory_opt_ = trajectory_opt;
  if (trajectory_opt) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.trajectory_opt)
}
inline ::roborts_local_planner::Trajectory* Config::release_trajectory_opt() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::roborts_local_planner::Trajectory* temp = _impl_.trajectory_opt_;
  _impl_.trajectory_opt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::Trajectory* Config::unsafe_arena_release_trajectory_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.trajectory_opt)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::roborts_local_planner::Trajectory* temp = _impl_.trajectory_opt_;
  _impl_.trajectory_opt_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::Trajectory* Config::_internal_mutable_trajectory_opt() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trajectory_opt_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Trajectory>(GetArenaForAllocation());
    _impl_.trajectory_opt_ = p;
  }
  return _impl_.trajectory_opt_;
}
inline ::roborts_local_planner::Trajectory* Config::mutable_trajectory_opt() {
  ::roborts_local_planner::Trajectory* _msg = _internal_mutable_trajectory_opt();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.trajectory_opt)
  return _msg;
}
inline void Config::set_allocated_trajectory_opt(::roborts_local_planner::Trajectory* trajectory_opt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trajectory_opt_;
  }
  if (trajectory_opt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trajectory_opt);
    if (message_arena != submessage_arena) {
      trajectory_opt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_opt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trajectory_opt_ = trajectory_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.trajectory_opt)
}

// optional .roborts_local_planner.Robot kinematics_opt = 3;
inline bool Config::_internal_has_kinematics_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kinematics_opt_ != nullptr);
  return value;
}
inline bool Config::has_kinematics_opt() const {
  return _internal_has_kinematics_opt();
}
inline void Config::clear_kinematics_opt() {
  if (_impl_.kinematics_opt_ != nullptr) _impl_.kinematics_opt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::roborts_local_planner::Robot& Config::_internal_kinematics_opt() const {
  const ::roborts_local_planner::Robot* p = _impl_.kinematics_opt_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::Robot&>(
      ::roborts_local_planner::_Robot_default_instance_);
}
inline const ::roborts_local_planner::Robot& Config::kinematics_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.kinematics_opt)
  return _internal_kinematics_opt();
}
inline void Config::unsafe_arena_set_allocated_kinematics_opt(
    ::roborts_local_planner::Robot* kinematics_opt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kinematics_opt_);
  }
  _impl_.kinematics_opt_ = kinematics_opt;
  if (kinematics_opt) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.kinematics_opt)
}
inline ::roborts_local_planner::Robot* Config::release_kinematics_opt() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::roborts_local_planner::Robot* temp = _impl_.kinematics_opt_;
  _impl_.kinematics_opt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::Robot* Config::unsafe_arena_release_kinematics_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.kinematics_opt)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::roborts_local_planner::Robot* temp = _impl_.kinematics_opt_;
  _impl_.kinematics_opt_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::Robot* Config::_internal_mutable_kinematics_opt() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.kinematics_opt_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Robot>(GetArenaForAllocation());
    _impl_.kinematics_opt_ = p;
  }
  return _impl_.kinematics_opt_;
}
inline ::roborts_local_planner::Robot* Config::mutable_kinematics_opt() {
  ::roborts_local_planner::Robot* _msg = _internal_mutable_kinematics_opt();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.kinematics_opt)
  return _msg;
}
inline void Config::set_allocated_kinematics_opt(::roborts_local_planner::Robot* kinematics_opt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kinematics_opt_;
  }
  if (kinematics_opt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kinematics_opt);
    if (message_arena != submessage_arena) {
      kinematics_opt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kinematics_opt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.kinematics_opt_ = kinematics_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.kinematics_opt)
}

// optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
inline bool Config::_internal_has_tolerance_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tolerance_opt_ != nullptr);
  return value;
}
inline bool Config::has_tolerance_opt() const {
  return _internal_has_tolerance_opt();
}
inline void Config::clear_tolerance_opt() {
  if (_impl_.tolerance_opt_ != nullptr) _impl_.tolerance_opt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::roborts_local_planner::GoalTolerance& Config::_internal_tolerance_opt() const {
  const ::roborts_local_planner::GoalTolerance* p = _impl_.tolerance_opt_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::GoalTolerance&>(
      ::roborts_local_planner::_GoalTolerance_default_instance_);
}
inline const ::roborts_local_planner::GoalTolerance& Config::tolerance_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.tolerance_opt)
  return _internal_tolerance_opt();
}
inline void Config::unsafe_arena_set_allocated_tolerance_opt(
    ::roborts_local_planner::GoalTolerance* tolerance_opt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tolerance_opt_);
  }
  _impl_.tolerance_opt_ = tolerance_opt;
  if (tolerance_opt) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.tolerance_opt)
}
inline ::roborts_local_planner::GoalTolerance* Config::release_tolerance_opt() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::roborts_local_planner::GoalTolerance* temp = _impl_.tolerance_opt_;
  _impl_.tolerance_opt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::GoalTolerance* Config::unsafe_arena_release_tolerance_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.tolerance_opt)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::roborts_local_planner::GoalTolerance* temp = _impl_.tolerance_opt_;
  _impl_.tolerance_opt_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::GoalTolerance* Config::_internal_mutable_tolerance_opt() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tolerance_opt_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::GoalTolerance>(GetArenaForAllocation());
    _impl_.tolerance_opt_ = p;
  }
  return _impl_.tolerance_opt_;
}
inline ::roborts_local_planner::GoalTolerance* Config::mutable_tolerance_opt() {
  ::roborts_local_planner::GoalTolerance* _msg = _internal_mutable_tolerance_opt();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.tolerance_opt)
  return _msg;
}
inline void Config::set_allocated_tolerance_opt(::roborts_local_planner::GoalTolerance* tolerance_opt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tolerance_opt_;
  }
  if (tolerance_opt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tolerance_opt);
    if (message_arena != submessage_arena) {
      tolerance_opt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tolerance_opt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tolerance_opt_ = tolerance_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.tolerance_opt)
}

// optional .roborts_local_planner.Obstacles obstacles_opt = 5;
inline bool Config::_internal_has_obstacles_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obstacles_opt_ != nullptr);
  return value;
}
inline bool Config::has_obstacles_opt() const {
  return _internal_has_obstacles_opt();
}
inline void Config::clear_obstacles_opt() {
  if (_impl_.obstacles_opt_ != nullptr) _impl_.obstacles_opt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::roborts_local_planner::Obstacles& Config::_internal_obstacles_opt() const {
  const ::roborts_local_planner::Obstacles* p = _impl_.obstacles_opt_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::Obstacles&>(
      ::roborts_local_planner::_Obstacles_default_instance_);
}
inline const ::roborts_local_planner::Obstacles& Config::obstacles_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.obstacles_opt)
  return _internal_obstacles_opt();
}
inline void Config::unsafe_arena_set_allocated_obstacles_opt(
    ::roborts_local_planner::Obstacles* obstacles_opt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obstacles_opt_);
  }
  _impl_.obstacles_opt_ = obstacles_opt;
  if (obstacles_opt) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.obstacles_opt)
}
inline ::roborts_local_planner::Obstacles* Config::release_obstacles_opt() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::roborts_local_planner::Obstacles* temp = _impl_.obstacles_opt_;
  _impl_.obstacles_opt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::Obstacles* Config::unsafe_arena_release_obstacles_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.obstacles_opt)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::roborts_local_planner::Obstacles* temp = _impl_.obstacles_opt_;
  _impl_.obstacles_opt_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::Obstacles* Config::_internal_mutable_obstacles_opt() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.obstacles_opt_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Obstacles>(GetArenaForAllocation());
    _impl_.obstacles_opt_ = p;
  }
  return _impl_.obstacles_opt_;
}
inline ::roborts_local_planner::Obstacles* Config::mutable_obstacles_opt() {
  ::roborts_local_planner::Obstacles* _msg = _internal_mutable_obstacles_opt();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.obstacles_opt)
  return _msg;
}
inline void Config::set_allocated_obstacles_opt(::roborts_local_planner::Obstacles* obstacles_opt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obstacles_opt_;
  }
  if (obstacles_opt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obstacles_opt);
    if (message_arena != submessage_arena) {
      obstacles_opt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obstacles_opt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.obstacles_opt_ = obstacles_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.obstacles_opt)
}

// optional .roborts_local_planner.Optimization optimize_info = 6;
inline bool Config::_internal_has_optimize_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.optimize_info_ != nullptr);
  return value;
}
inline bool Config::has_optimize_info() const {
  return _internal_has_optimize_info();
}
inline void Config::clear_optimize_info() {
  if (_impl_.optimize_info_ != nullptr) _impl_.optimize_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::roborts_local_planner::Optimization& Config::_internal_optimize_info() const {
  const ::roborts_local_planner::Optimization* p = _impl_.optimize_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::Optimization&>(
      ::roborts_local_planner::_Optimization_default_instance_);
}
inline const ::roborts_local_planner::Optimization& Config::optimize_info() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.optimize_info)
  return _internal_optimize_info();
}
inline void Config::unsafe_arena_set_allocated_optimize_info(
    ::roborts_local_planner::Optimization* optimize_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optimize_info_);
  }
  _impl_.optimize_info_ = optimize_info;
  if (optimize_info) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.optimize_info)
}
inline ::roborts_local_planner::Optimization* Config::release_optimize_info() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::roborts_local_planner::Optimization* temp = _impl_.optimize_info_;
  _impl_.optimize_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::Optimization* Config::unsafe_arena_release_optimize_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.optimize_info)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::roborts_local_planner::Optimization* temp = _impl_.optimize_info_;
  _impl_.optimize_info_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::Optimization* Config::_internal_mutable_optimize_info() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.optimize_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Optimization>(GetArenaForAllocation());
    _impl_.optimize_info_ = p;
  }
  return _impl_.optimize_info_;
}
inline ::roborts_local_planner::Optimization* Config::mutable_optimize_info() {
  ::roborts_local_planner::Optimization* _msg = _internal_mutable_optimize_info();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.optimize_info)
  return _msg;
}
inline void Config::set_allocated_optimize_info(::roborts_local_planner::Optimization* optimize_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optimize_info_;
  }
  if (optimize_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optimize_info);
    if (message_arena != submessage_arena) {
      optimize_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimize_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.optimize_info_ = optimize_info;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.optimize_info)
}

// optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
inline bool Config::_internal_has_hcp_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hcp_opt_ != nullptr);
  return value;
}
inline bool Config::has_hcp_opt() const {
  return _internal_has_hcp_opt();
}
inline void Config::clear_hcp_opt() {
  if (_impl_.hcp_opt_ != nullptr) _impl_.hcp_opt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::roborts_local_planner::HomotopyClassPlanner& Config::_internal_hcp_opt() const {
  const ::roborts_local_planner::HomotopyClassPlanner* p = _impl_.hcp_opt_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::HomotopyClassPlanner&>(
      ::roborts_local_planner::_HomotopyClassPlanner_default_instance_);
}
inline const ::roborts_local_planner::HomotopyClassPlanner& Config::hcp_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.hcp_opt)
  return _internal_hcp_opt();
}
inline void Config::unsafe_arena_set_allocated_hcp_opt(
    ::roborts_local_planner::HomotopyClassPlanner* hcp_opt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hcp_opt_);
  }
  _impl_.hcp_opt_ = hcp_opt;
  if (hcp_opt) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.hcp_opt)
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::release_hcp_opt() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::roborts_local_planner::HomotopyClassPlanner* temp = _impl_.hcp_opt_;
  _impl_.hcp_opt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::unsafe_arena_release_hcp_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.hcp_opt)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::roborts_local_planner::HomotopyClassPlanner* temp = _impl_.hcp_opt_;
  _impl_.hcp_opt_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::_internal_mutable_hcp_opt() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.hcp_opt_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::HomotopyClassPlanner>(GetArenaForAllocation());
    _impl_.hcp_opt_ = p;
  }
  return _impl_.hcp_opt_;
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::mutable_hcp_opt() {
  ::roborts_local_planner::HomotopyClassPlanner* _msg = _internal_mutable_hcp_opt();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.hcp_opt)
  return _msg;
}
inline void Config::set_allocated_hcp_opt(::roborts_local_planner::HomotopyClassPlanner* hcp_opt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hcp_opt_;
  }
  if (hcp_opt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hcp_opt);
    if (message_arena != submessage_arena) {
      hcp_opt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hcp_opt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.hcp_opt_ = hcp_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.hcp_opt)
}

// repeated .roborts_local_planner.FootprintModel robot_type = 8;
inline int Config::_internal_robot_type_size() const {
  return _impl_.robot_type_.size();
}
inline int Config::robot_type_size() const {
  return _internal_robot_type_size();
}
inline void Config::clear_robot_type() {
  _impl_.robot_type_.Clear();
}
inline ::roborts_local_planner::FootprintModel* Config::mutable_robot_type(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.robot_type)
  return _impl_.robot_type_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::FootprintModel >*
Config::mutable_robot_type() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.Config.robot_type)
  return &_impl_.robot_type_;
}
inline const ::roborts_local_planner::FootprintModel& Config::_internal_robot_type(int index) const {
  return _impl_.robot_type_.Get(index);
}
inline const ::roborts_local_planner::FootprintModel& Config::robot_type(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.robot_type)
  return _internal_robot_type(index);
}
inline ::roborts_local_planner::FootprintModel* Config::_internal_add_robot_type() {
  return _impl_.robot_type_.Add();
}
inline ::roborts_local_planner::FootprintModel* Config::add_robot_type() {
  ::roborts_local_planner::FootprintModel* _add = _internal_add_robot_type();
  // @@protoc_insertion_point(field_add:roborts_local_planner.Config.robot_type)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::roborts_local_planner::FootprintModel >&
Config::robot_type() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.Config.robot_type)
  return _impl_.robot_type_;
}

// optional .roborts_local_planner.Recovery recovery_info = 9;
inline bool Config::_internal_has_recovery_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recovery_info_ != nullptr);
  return value;
}
inline bool Config::has_recovery_info() const {
  return _internal_has_recovery_info();
}
inline void Config::clear_recovery_info() {
  if (_impl_.recovery_info_ != nullptr) _impl_.recovery_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::roborts_local_planner::Recovery& Config::_internal_recovery_info() const {
  const ::roborts_local_planner::Recovery* p = _impl_.recovery_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::roborts_local_planner::Recovery&>(
      ::roborts_local_planner::_Recovery_default_instance_);
}
inline const ::roborts_local_planner::Recovery& Config::recovery_info() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.recovery_info)
  return _internal_recovery_info();
}
inline void Config::unsafe_arena_set_allocated_recovery_info(
    ::roborts_local_planner::Recovery* recovery_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recovery_info_);
  }
  _impl_.recovery_info_ = recovery_info;
  if (recovery_info) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:roborts_local_planner.Config.recovery_info)
}
inline ::roborts_local_planner::Recovery* Config::release_recovery_info() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::roborts_local_planner::Recovery* temp = _impl_.recovery_info_;
  _impl_.recovery_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::roborts_local_planner::Recovery* Config::unsafe_arena_release_recovery_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.recovery_info)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::roborts_local_planner::Recovery* temp = _impl_.recovery_info_;
  _impl_.recovery_info_ = nullptr;
  return temp;
}
inline ::roborts_local_planner::Recovery* Config::_internal_mutable_recovery_info() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.recovery_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Recovery>(GetArenaForAllocation());
    _impl_.recovery_info_ = p;
  }
  return _impl_.recovery_info_;
}
inline ::roborts_local_planner::Recovery* Config::mutable_recovery_info() {
  ::roborts_local_planner::Recovery* _msg = _internal_mutable_recovery_info();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.recovery_info)
  return _msg;
}
inline void Config::set_allocated_recovery_info(::roborts_local_planner::Recovery* recovery_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recovery_info_;
  }
  if (recovery_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recovery_info);
    if (message_arena != submessage_arena) {
      recovery_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recovery_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.recovery_info_ = recovery_info;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.recovery_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_local_planner

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::roborts_local_planner::FootprintModel_FootprintType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::roborts_local_planner::FootprintModel_FootprintType>() {
  return ::roborts_local_planner::FootprintModel_FootprintType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto
