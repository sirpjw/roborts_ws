// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decision.proto

#include "decision.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace roborts_decision {
PROTOBUF_CONSTEXPR Point::Point(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.roll_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.yaw_)*/0} {}
struct PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointDefaultTypeInternal() {}
  union {
    Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointDefaultTypeInternal _Point_default_instance_;
PROTOBUF_CONSTEXPR EscapeConstraint::EscapeConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.left_x_limit_)*/0
  , /*decltype(_impl_.right_x_limit_)*/0
  , /*decltype(_impl_.robot_x_limit_)*/0
  , /*decltype(_impl_.left_random_min_x_)*/0
  , /*decltype(_impl_.left_random_max_x_)*/0
  , /*decltype(_impl_.right_random_min_x_)*/0
  , /*decltype(_impl_.right_random_max_x_)*/0} {}
struct EscapeConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EscapeConstraintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EscapeConstraintDefaultTypeInternal() {}
  union {
    EscapeConstraint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EscapeConstraintDefaultTypeInternal _EscapeConstraint_default_instance_;
PROTOBUF_CONSTEXPR SearchConstraint::SearchConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_limit_)*/0
  , /*decltype(_impl_.y_limit_)*/0} {}
struct SearchConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchConstraintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchConstraintDefaultTypeInternal() {}
  union {
    SearchConstraint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchConstraintDefaultTypeInternal _SearchConstraint_default_instance_;
PROTOBUF_CONSTEXPR WhirlVel::WhirlVel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_x_vel_)*/0
  , /*decltype(_impl_.angle_y_vel_)*/0
  , /*decltype(_impl_.angle_z_vel_)*/0} {}
struct WhirlVelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhirlVelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhirlVelDefaultTypeInternal() {}
  union {
    WhirlVel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhirlVelDefaultTypeInternal _WhirlVel_default_instance_;
PROTOBUF_CONSTEXPR MultiRobot::MultiRobot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_position_)*/nullptr} {}
struct MultiRobotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultiRobotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultiRobotDefaultTypeInternal() {}
  union {
    MultiRobot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultiRobotDefaultTypeInternal _MultiRobot_default_instance_;
PROTOBUF_CONSTEXPR DecisionConfig::DecisionConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/{}
  , /*decltype(_impl_.buff_point_)*/{}
  , /*decltype(_impl_.search_region_1_)*/{}
  , /*decltype(_impl_.search_region_2_)*/{}
  , /*decltype(_impl_.search_region_3_)*/{}
  , /*decltype(_impl_.search_region_4_)*/{}
  , /*decltype(_impl_.escape_)*/nullptr
  , /*decltype(_impl_.search_limit_)*/nullptr
  , /*decltype(_impl_.whirl_vel_)*/nullptr
  , /*decltype(_impl_.wing_bot_)*/nullptr
  , /*decltype(_impl_.master_bot_)*/nullptr
  , /*decltype(_impl_.wing_bot_task_point_)*/nullptr
  , /*decltype(_impl_.simulate_)*/false
  , /*decltype(_impl_.master_)*/false} {}
struct DecisionConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecisionConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecisionConfigDefaultTypeInternal() {}
  union {
    DecisionConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecisionConfigDefaultTypeInternal _DecisionConfig_default_instance_;
}  // namespace roborts_decision
static ::_pb::Metadata file_level_metadata_decision_2eproto[6];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_decision_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_decision_2eproto = nullptr;

const uint32_t TableStruct_decision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.roll_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::Point, _impl_.yaw_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.left_x_limit_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.right_x_limit_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.robot_x_limit_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.left_random_min_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.left_random_max_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.right_random_min_x_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::EscapeConstraint, _impl_.right_random_max_x_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::roborts_decision::SearchConstraint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::SearchConstraint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::SearchConstraint, _impl_.x_limit_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::SearchConstraint, _impl_.y_limit_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::roborts_decision::WhirlVel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::WhirlVel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::WhirlVel, _impl_.angle_x_vel_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::WhirlVel, _impl_.angle_y_vel_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::WhirlVel, _impl_.angle_z_vel_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::roborts_decision::MultiRobot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::MultiRobot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::MultiRobot, _impl_.start_position_),
  0,
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.simulate_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.master_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.escape_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.buff_point_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.search_limit_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.whirl_vel_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.wing_bot_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.master_bot_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.wing_bot_task_point_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.search_region_1_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.search_region_2_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.search_region_3_),
  PROTOBUF_FIELD_OFFSET(::roborts_decision::DecisionConfig, _impl_.search_region_4_),
  ~0u,
  6,
  7,
  0,
  ~0u,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::roborts_decision::Point)},
  { 18, 31, -1, sizeof(::roborts_decision::EscapeConstraint)},
  { 38, 46, -1, sizeof(::roborts_decision::SearchConstraint)},
  { 48, 57, -1, sizeof(::roborts_decision::WhirlVel)},
  { 60, 67, -1, sizeof(::roborts_decision::MultiRobot)},
  { 68, 88, -1, sizeof(::roborts_decision::DecisionConfig)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::roborts_decision::_Point_default_instance_._instance,
  &::roborts_decision::_EscapeConstraint_default_instance_._instance,
  &::roborts_decision::_SearchConstraint_default_instance_._instance,
  &::roborts_decision::_WhirlVel_default_instance_._instance,
  &::roborts_decision::_MultiRobot_default_instance_._instance,
  &::roborts_decision::_DecisionConfig_default_instance_._instance,
};

const char descriptor_table_protodef_decision_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016decision.proto\022\020roborts_decision\"R\n\005Po"
  "int\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\014\n\004"
  "roll\030\004 \001(\002\022\r\n\005pitch\030\005 \001(\002\022\013\n\003yaw\030\006 \001(\002\"\304"
  "\001\n\020EscapeConstraint\022\024\n\014left_x_limit\030\001 \001("
  "\002\022\025\n\rright_x_limit\030\002 \001(\002\022\025\n\rrobot_x_limi"
  "t\030\003 \001(\002\022\031\n\021left_random_min_x\030\004 \001(\002\022\031\n\021le"
  "ft_random_max_x\030\005 \001(\002\022\032\n\022right_random_mi"
  "n_x\030\006 \001(\002\022\032\n\022right_random_max_x\030\007 \001(\002\"4\n"
  "\020SearchConstraint\022\017\n\007x_limit\030\001 \001(\002\022\017\n\007y_"
  "limit\030\002 \001(\002\"I\n\010WhirlVel\022\023\n\013angle_x_vel\030\001"
  " \001(\002\022\023\n\013angle_y_vel\030\002 \001(\002\022\023\n\013angle_z_vel"
  "\030\003 \001(\002\"=\n\nMultiRobot\022/\n\016start_position\030\007"
  " \001(\0132\027.roborts_decision.Point\"\222\005\n\016Decisi"
  "onConfig\022&\n\005point\030\001 \003(\0132\027.roborts_decisi"
  "on.Point\022\027\n\010simulate\030\002 \001(\010:\005false\022\025\n\006mas"
  "ter\030\003 \001(\010:\005false\0222\n\006escape\030\004 \001(\0132\".robor"
  "ts_decision.EscapeConstraint\022+\n\nbuff_poi"
  "nt\030\005 \003(\0132\027.roborts_decision.Point\0228\n\014sea"
  "rch_limit\030\006 \001(\0132\".roborts_decision.Searc"
  "hConstraint\022-\n\twhirl_vel\030\007 \001(\0132\032.roborts"
  "_decision.WhirlVel\022.\n\010wing_bot\030\010 \001(\0132\034.r"
  "oborts_decision.MultiRobot\0220\n\nmaster_bot"
  "\030\t \001(\0132\034.roborts_decision.MultiRobot\0224\n\023"
  "wing_bot_task_point\030\n \001(\0132\027.roborts_deci"
  "sion.Point\0220\n\017search_region_1\030\013 \003(\0132\027.ro"
  "borts_decision.Point\0220\n\017search_region_2\030"
  "\014 \003(\0132\027.roborts_decision.Point\0220\n\017search"
  "_region_3\030\r \003(\0132\027.roborts_decision.Point"
  "\0220\n\017search_region_4\030\016 \003(\0132\027.roborts_deci"
  "sion.Point"
  ;
static ::_pbi::once_flag descriptor_table_decision_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_decision_2eproto = {
    false, false, 1170, descriptor_table_protodef_decision_2eproto,
    "decision.proto",
    &descriptor_table_decision_2eproto_once, nullptr, 0, 6,
    schemas, file_default_instances, TableStruct_decision_2eproto::offsets,
    file_level_metadata_decision_2eproto, file_level_enum_descriptors_decision_2eproto,
    file_level_service_descriptors_decision_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_decision_2eproto_getter() {
  return &descriptor_table_decision_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_decision_2eproto(&descriptor_table_decision_2eproto);
namespace roborts_decision {

// ===================================================================

class Point::_Internal {
 public:
  using HasBits = decltype(std::declval<Point>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Point* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.roll_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.yaw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:roborts_decision.Point)
}

inline void Point::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.roll_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.yaw_){0}
  };
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:roborts_decision.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.yaw_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.yaw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float roll = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_roll(&has_bits);
          _impl_.roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float pitch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_pitch(&has_bits);
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_yaw(&has_bits);
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // optional float roll = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_roll(), target);
  }

  // optional float pitch = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_pitch(), target);
  }

  // optional float yaw = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.Point)
  return target;
}

size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.Point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float roll = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float pitch = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float yaw = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point::GetClassData() const { return &_class_data_; }


void Point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Point*>(&to_msg);
  auto& from = static_cast<const Point&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.Point)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.roll_ = from._impl_.roll_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pitch_ = from._impl_.pitch_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.yaw_ = from._impl_.yaw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, _impl_.yaw_)
      + sizeof(Point::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(Point, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[0]);
}

// ===================================================================

class EscapeConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<EscapeConstraint>()._impl_._has_bits_);
  static void set_has_left_x_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_right_x_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_robot_x_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_left_random_min_x(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_left_random_max_x(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_right_random_min_x(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_right_random_max_x(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

EscapeConstraint::EscapeConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.EscapeConstraint)
}
EscapeConstraint::EscapeConstraint(const EscapeConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EscapeConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_x_limit_){}
    , decltype(_impl_.right_x_limit_){}
    , decltype(_impl_.robot_x_limit_){}
    , decltype(_impl_.left_random_min_x_){}
    , decltype(_impl_.left_random_max_x_){}
    , decltype(_impl_.right_random_min_x_){}
    , decltype(_impl_.right_random_max_x_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.left_x_limit_, &from._impl_.left_x_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_random_max_x_) -
    reinterpret_cast<char*>(&_impl_.left_x_limit_)) + sizeof(_impl_.right_random_max_x_));
  // @@protoc_insertion_point(copy_constructor:roborts_decision.EscapeConstraint)
}

inline void EscapeConstraint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_x_limit_){0}
    , decltype(_impl_.right_x_limit_){0}
    , decltype(_impl_.robot_x_limit_){0}
    , decltype(_impl_.left_random_min_x_){0}
    , decltype(_impl_.left_random_max_x_){0}
    , decltype(_impl_.right_random_min_x_){0}
    , decltype(_impl_.right_random_max_x_){0}
  };
}

EscapeConstraint::~EscapeConstraint() {
  // @@protoc_insertion_point(destructor:roborts_decision.EscapeConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EscapeConstraint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EscapeConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EscapeConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.EscapeConstraint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.left_x_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.right_random_max_x_) -
        reinterpret_cast<char*>(&_impl_.left_x_limit_)) + sizeof(_impl_.right_random_max_x_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EscapeConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float left_x_limit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_left_x_limit(&has_bits);
          _impl_.left_x_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float right_x_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_right_x_limit(&has_bits);
          _impl_.right_x_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float robot_x_limit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_robot_x_limit(&has_bits);
          _impl_.robot_x_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float left_random_min_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_left_random_min_x(&has_bits);
          _impl_.left_random_min_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float left_random_max_x = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_left_random_max_x(&has_bits);
          _impl_.left_random_max_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float right_random_min_x = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_right_random_min_x(&has_bits);
          _impl_.right_random_min_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float right_random_max_x = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_right_random_max_x(&has_bits);
          _impl_.right_random_max_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EscapeConstraint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.EscapeConstraint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float left_x_limit = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_left_x_limit(), target);
  }

  // optional float right_x_limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_right_x_limit(), target);
  }

  // optional float robot_x_limit = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_robot_x_limit(), target);
  }

  // optional float left_random_min_x = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_left_random_min_x(), target);
  }

  // optional float left_random_max_x = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_left_random_max_x(), target);
  }

  // optional float right_random_min_x = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_right_random_min_x(), target);
  }

  // optional float right_random_max_x = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_right_random_max_x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.EscapeConstraint)
  return target;
}

size_t EscapeConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.EscapeConstraint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional float left_x_limit = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float right_x_limit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float robot_x_limit = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float left_random_min_x = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float left_random_max_x = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float right_random_min_x = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float right_random_max_x = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EscapeConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EscapeConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EscapeConstraint::GetClassData() const { return &_class_data_; }


void EscapeConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EscapeConstraint*>(&to_msg);
  auto& from = static_cast<const EscapeConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.EscapeConstraint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.left_x_limit_ = from._impl_.left_x_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.right_x_limit_ = from._impl_.right_x_limit_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.robot_x_limit_ = from._impl_.robot_x_limit_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.left_random_min_x_ = from._impl_.left_random_min_x_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.left_random_max_x_ = from._impl_.left_random_max_x_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.right_random_min_x_ = from._impl_.right_random_min_x_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.right_random_max_x_ = from._impl_.right_random_max_x_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EscapeConstraint::CopyFrom(const EscapeConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.EscapeConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EscapeConstraint::IsInitialized() const {
  return true;
}

void EscapeConstraint::InternalSwap(EscapeConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EscapeConstraint, _impl_.right_random_max_x_)
      + sizeof(EscapeConstraint::_impl_.right_random_max_x_)
      - PROTOBUF_FIELD_OFFSET(EscapeConstraint, _impl_.left_x_limit_)>(
          reinterpret_cast<char*>(&_impl_.left_x_limit_),
          reinterpret_cast<char*>(&other->_impl_.left_x_limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EscapeConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[1]);
}

// ===================================================================

class SearchConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<SearchConstraint>()._impl_._has_bits_);
  static void set_has_x_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SearchConstraint::SearchConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.SearchConstraint)
}
SearchConstraint::SearchConstraint(const SearchConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SearchConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_limit_){}
    , decltype(_impl_.y_limit_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_limit_, &from._impl_.x_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_limit_) -
    reinterpret_cast<char*>(&_impl_.x_limit_)) + sizeof(_impl_.y_limit_));
  // @@protoc_insertion_point(copy_constructor:roborts_decision.SearchConstraint)
}

inline void SearchConstraint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_limit_){0}
    , decltype(_impl_.y_limit_){0}
  };
}

SearchConstraint::~SearchConstraint() {
  // @@protoc_insertion_point(destructor:roborts_decision.SearchConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SearchConstraint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SearchConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SearchConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.SearchConstraint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_limit_) -
        reinterpret_cast<char*>(&_impl_.x_limit_)) + sizeof(_impl_.y_limit_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SearchConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x_limit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x_limit(&has_bits);
          _impl_.x_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y_limit(&has_bits);
          _impl_.y_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SearchConstraint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.SearchConstraint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x_limit = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x_limit(), target);
  }

  // optional float y_limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.SearchConstraint)
  return target;
}

size_t SearchConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.SearchConstraint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x_limit = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y_limit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SearchConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SearchConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SearchConstraint::GetClassData() const { return &_class_data_; }


void SearchConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SearchConstraint*>(&to_msg);
  auto& from = static_cast<const SearchConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.SearchConstraint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_limit_ = from._impl_.x_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_limit_ = from._impl_.y_limit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SearchConstraint::CopyFrom(const SearchConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.SearchConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchConstraint::IsInitialized() const {
  return true;
}

void SearchConstraint::InternalSwap(SearchConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SearchConstraint, _impl_.y_limit_)
      + sizeof(SearchConstraint::_impl_.y_limit_)
      - PROTOBUF_FIELD_OFFSET(SearchConstraint, _impl_.x_limit_)>(
          reinterpret_cast<char*>(&_impl_.x_limit_),
          reinterpret_cast<char*>(&other->_impl_.x_limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SearchConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[2]);
}

// ===================================================================

class WhirlVel::_Internal {
 public:
  using HasBits = decltype(std::declval<WhirlVel>()._impl_._has_bits_);
  static void set_has_angle_x_vel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle_y_vel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_angle_z_vel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WhirlVel::WhirlVel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.WhirlVel)
}
WhirlVel::WhirlVel(const WhirlVel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhirlVel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_x_vel_){}
    , decltype(_impl_.angle_y_vel_){}
    , decltype(_impl_.angle_z_vel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.angle_x_vel_, &from._impl_.angle_x_vel_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.angle_z_vel_) -
    reinterpret_cast<char*>(&_impl_.angle_x_vel_)) + sizeof(_impl_.angle_z_vel_));
  // @@protoc_insertion_point(copy_constructor:roborts_decision.WhirlVel)
}

inline void WhirlVel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_x_vel_){0}
    , decltype(_impl_.angle_y_vel_){0}
    , decltype(_impl_.angle_z_vel_){0}
  };
}

WhirlVel::~WhirlVel() {
  // @@protoc_insertion_point(destructor:roborts_decision.WhirlVel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhirlVel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WhirlVel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhirlVel::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.WhirlVel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.angle_x_vel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.angle_z_vel_) -
        reinterpret_cast<char*>(&_impl_.angle_x_vel_)) + sizeof(_impl_.angle_z_vel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhirlVel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float angle_x_vel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_angle_x_vel(&has_bits);
          _impl_.angle_x_vel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float angle_y_vel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_angle_y_vel(&has_bits);
          _impl_.angle_y_vel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float angle_z_vel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_angle_z_vel(&has_bits);
          _impl_.angle_z_vel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhirlVel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.WhirlVel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float angle_x_vel = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_angle_x_vel(), target);
  }

  // optional float angle_y_vel = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_angle_y_vel(), target);
  }

  // optional float angle_z_vel = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_angle_z_vel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.WhirlVel)
  return target;
}

size_t WhirlVel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.WhirlVel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float angle_x_vel = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float angle_y_vel = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float angle_z_vel = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhirlVel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhirlVel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhirlVel::GetClassData() const { return &_class_data_; }


void WhirlVel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhirlVel*>(&to_msg);
  auto& from = static_cast<const WhirlVel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.WhirlVel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.angle_x_vel_ = from._impl_.angle_x_vel_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.angle_y_vel_ = from._impl_.angle_y_vel_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.angle_z_vel_ = from._impl_.angle_z_vel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhirlVel::CopyFrom(const WhirlVel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.WhirlVel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhirlVel::IsInitialized() const {
  return true;
}

void WhirlVel::InternalSwap(WhirlVel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WhirlVel, _impl_.angle_z_vel_)
      + sizeof(WhirlVel::_impl_.angle_z_vel_)
      - PROTOBUF_FIELD_OFFSET(WhirlVel, _impl_.angle_x_vel_)>(
          reinterpret_cast<char*>(&_impl_.angle_x_vel_),
          reinterpret_cast<char*>(&other->_impl_.angle_x_vel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WhirlVel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[3]);
}

// ===================================================================

class MultiRobot::_Internal {
 public:
  using HasBits = decltype(std::declval<MultiRobot>()._impl_._has_bits_);
  static const ::roborts_decision::Point& start_position(const MultiRobot* msg);
  static void set_has_start_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::roborts_decision::Point&
MultiRobot::_Internal::start_position(const MultiRobot* msg) {
  return *msg->_impl_.start_position_;
}
MultiRobot::MultiRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.MultiRobot)
}
MultiRobot::MultiRobot(const MultiRobot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MultiRobot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start_position()) {
    _this->_impl_.start_position_ = new ::roborts_decision::Point(*from._impl_.start_position_);
  }
  // @@protoc_insertion_point(copy_constructor:roborts_decision.MultiRobot)
}

inline void MultiRobot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_position_){nullptr}
  };
}

MultiRobot::~MultiRobot() {
  // @@protoc_insertion_point(destructor:roborts_decision.MultiRobot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultiRobot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_position_;
}

void MultiRobot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultiRobot::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.MultiRobot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.start_position_ != nullptr);
    _impl_.start_position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MultiRobot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .roborts_decision.Point start_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiRobot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.MultiRobot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .roborts_decision.Point start_position = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::start_position(this),
        _Internal::start_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.MultiRobot)
  return target;
}

size_t MultiRobot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.MultiRobot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .roborts_decision.Point start_position = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MultiRobot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MultiRobot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MultiRobot::GetClassData() const { return &_class_data_; }


void MultiRobot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MultiRobot*>(&to_msg);
  auto& from = static_cast<const MultiRobot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.MultiRobot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_start_position()) {
    _this->_internal_mutable_start_position()->::roborts_decision::Point::MergeFrom(
        from._internal_start_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MultiRobot::CopyFrom(const MultiRobot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.MultiRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiRobot::IsInitialized() const {
  return true;
}

void MultiRobot::InternalSwap(MultiRobot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.start_position_, other->_impl_.start_position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiRobot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[4]);
}

// ===================================================================

class DecisionConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<DecisionConfig>()._impl_._has_bits_);
  static void set_has_simulate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_master(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::roborts_decision::EscapeConstraint& escape(const DecisionConfig* msg);
  static void set_has_escape(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::roborts_decision::SearchConstraint& search_limit(const DecisionConfig* msg);
  static void set_has_search_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::roborts_decision::WhirlVel& whirl_vel(const DecisionConfig* msg);
  static void set_has_whirl_vel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::roborts_decision::MultiRobot& wing_bot(const DecisionConfig* msg);
  static void set_has_wing_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::roborts_decision::MultiRobot& master_bot(const DecisionConfig* msg);
  static void set_has_master_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::roborts_decision::Point& wing_bot_task_point(const DecisionConfig* msg);
  static void set_has_wing_bot_task_point(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::roborts_decision::EscapeConstraint&
DecisionConfig::_Internal::escape(const DecisionConfig* msg) {
  return *msg->_impl_.escape_;
}
const ::roborts_decision::SearchConstraint&
DecisionConfig::_Internal::search_limit(const DecisionConfig* msg) {
  return *msg->_impl_.search_limit_;
}
const ::roborts_decision::WhirlVel&
DecisionConfig::_Internal::whirl_vel(const DecisionConfig* msg) {
  return *msg->_impl_.whirl_vel_;
}
const ::roborts_decision::MultiRobot&
DecisionConfig::_Internal::wing_bot(const DecisionConfig* msg) {
  return *msg->_impl_.wing_bot_;
}
const ::roborts_decision::MultiRobot&
DecisionConfig::_Internal::master_bot(const DecisionConfig* msg) {
  return *msg->_impl_.master_bot_;
}
const ::roborts_decision::Point&
DecisionConfig::_Internal::wing_bot_task_point(const DecisionConfig* msg) {
  return *msg->_impl_.wing_bot_task_point_;
}
DecisionConfig::DecisionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:roborts_decision.DecisionConfig)
}
DecisionConfig::DecisionConfig(const DecisionConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DecisionConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){from._impl_.point_}
    , decltype(_impl_.buff_point_){from._impl_.buff_point_}
    , decltype(_impl_.search_region_1_){from._impl_.search_region_1_}
    , decltype(_impl_.search_region_2_){from._impl_.search_region_2_}
    , decltype(_impl_.search_region_3_){from._impl_.search_region_3_}
    , decltype(_impl_.search_region_4_){from._impl_.search_region_4_}
    , decltype(_impl_.escape_){nullptr}
    , decltype(_impl_.search_limit_){nullptr}
    , decltype(_impl_.whirl_vel_){nullptr}
    , decltype(_impl_.wing_bot_){nullptr}
    , decltype(_impl_.master_bot_){nullptr}
    , decltype(_impl_.wing_bot_task_point_){nullptr}
    , decltype(_impl_.simulate_){}
    , decltype(_impl_.master_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_escape()) {
    _this->_impl_.escape_ = new ::roborts_decision::EscapeConstraint(*from._impl_.escape_);
  }
  if (from._internal_has_search_limit()) {
    _this->_impl_.search_limit_ = new ::roborts_decision::SearchConstraint(*from._impl_.search_limit_);
  }
  if (from._internal_has_whirl_vel()) {
    _this->_impl_.whirl_vel_ = new ::roborts_decision::WhirlVel(*from._impl_.whirl_vel_);
  }
  if (from._internal_has_wing_bot()) {
    _this->_impl_.wing_bot_ = new ::roborts_decision::MultiRobot(*from._impl_.wing_bot_);
  }
  if (from._internal_has_master_bot()) {
    _this->_impl_.master_bot_ = new ::roborts_decision::MultiRobot(*from._impl_.master_bot_);
  }
  if (from._internal_has_wing_bot_task_point()) {
    _this->_impl_.wing_bot_task_point_ = new ::roborts_decision::Point(*from._impl_.wing_bot_task_point_);
  }
  ::memcpy(&_impl_.simulate_, &from._impl_.simulate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.master_) -
    reinterpret_cast<char*>(&_impl_.simulate_)) + sizeof(_impl_.master_));
  // @@protoc_insertion_point(copy_constructor:roborts_decision.DecisionConfig)
}

inline void DecisionConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){arena}
    , decltype(_impl_.buff_point_){arena}
    , decltype(_impl_.search_region_1_){arena}
    , decltype(_impl_.search_region_2_){arena}
    , decltype(_impl_.search_region_3_){arena}
    , decltype(_impl_.search_region_4_){arena}
    , decltype(_impl_.escape_){nullptr}
    , decltype(_impl_.search_limit_){nullptr}
    , decltype(_impl_.whirl_vel_){nullptr}
    , decltype(_impl_.wing_bot_){nullptr}
    , decltype(_impl_.master_bot_){nullptr}
    , decltype(_impl_.wing_bot_task_point_){nullptr}
    , decltype(_impl_.simulate_){false}
    , decltype(_impl_.master_){false}
  };
}

DecisionConfig::~DecisionConfig() {
  // @@protoc_insertion_point(destructor:roborts_decision.DecisionConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecisionConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.point_.~RepeatedPtrField();
  _impl_.buff_point_.~RepeatedPtrField();
  _impl_.search_region_1_.~RepeatedPtrField();
  _impl_.search_region_2_.~RepeatedPtrField();
  _impl_.search_region_3_.~RepeatedPtrField();
  _impl_.search_region_4_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.escape_;
  if (this != internal_default_instance()) delete _impl_.search_limit_;
  if (this != internal_default_instance()) delete _impl_.whirl_vel_;
  if (this != internal_default_instance()) delete _impl_.wing_bot_;
  if (this != internal_default_instance()) delete _impl_.master_bot_;
  if (this != internal_default_instance()) delete _impl_.wing_bot_task_point_;
}

void DecisionConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DecisionConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_decision.DecisionConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.point_.Clear();
  _impl_.buff_point_.Clear();
  _impl_.search_region_1_.Clear();
  _impl_.search_region_2_.Clear();
  _impl_.search_region_3_.Clear();
  _impl_.search_region_4_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.escape_ != nullptr);
      _impl_.escape_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.search_limit_ != nullptr);
      _impl_.search_limit_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.whirl_vel_ != nullptr);
      _impl_.whirl_vel_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.wing_bot_ != nullptr);
      _impl_.wing_bot_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.master_bot_ != nullptr);
      _impl_.master_bot_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.wing_bot_task_point_ != nullptr);
      _impl_.wing_bot_task_point_->Clear();
    }
  }
  ::memset(&_impl_.simulate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.master_) -
      reinterpret_cast<char*>(&_impl_.simulate_)) + sizeof(_impl_.master_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecisionConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .roborts_decision.Point point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool simulate = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_simulate(&has_bits);
          _impl_.simulate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool master = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_master(&has_bits);
          _impl_.master_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.EscapeConstraint escape = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_escape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_decision.Point buff_point = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buff_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.SearchConstraint search_limit = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_search_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.WhirlVel whirl_vel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_whirl_vel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.MultiRobot wing_bot = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wing_bot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.MultiRobot master_bot = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_master_bot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .roborts_decision.Point wing_bot_task_point = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_wing_bot_task_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_decision.Point search_region_1 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_search_region_1(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_decision.Point search_region_2 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_search_region_2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_decision.Point search_region_3 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_search_region_3(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .roborts_decision.Point search_region_4 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_search_region_4(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DecisionConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_decision.DecisionConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .roborts_decision.Point point = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_point_size()); i < n; i++) {
    const auto& repfield = this->_internal_point(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool simulate = 2 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_simulate(), target);
  }

  // optional bool master = 3 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_master(), target);
  }

  // optional .roborts_decision.EscapeConstraint escape = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::escape(this),
        _Internal::escape(this).GetCachedSize(), target, stream);
  }

  // repeated .roborts_decision.Point buff_point = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buff_point_size()); i < n; i++) {
    const auto& repfield = this->_internal_buff_point(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .roborts_decision.SearchConstraint search_limit = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::search_limit(this),
        _Internal::search_limit(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_decision.WhirlVel whirl_vel = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::whirl_vel(this),
        _Internal::whirl_vel(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_decision.MultiRobot wing_bot = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::wing_bot(this),
        _Internal::wing_bot(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_decision.MultiRobot master_bot = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::master_bot(this),
        _Internal::master_bot(this).GetCachedSize(), target, stream);
  }

  // optional .roborts_decision.Point wing_bot_task_point = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::wing_bot_task_point(this),
        _Internal::wing_bot_task_point(this).GetCachedSize(), target, stream);
  }

  // repeated .roborts_decision.Point search_region_1 = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_search_region_1_size()); i < n; i++) {
    const auto& repfield = this->_internal_search_region_1(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .roborts_decision.Point search_region_2 = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_search_region_2_size()); i < n; i++) {
    const auto& repfield = this->_internal_search_region_2(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .roborts_decision.Point search_region_3 = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_search_region_3_size()); i < n; i++) {
    const auto& repfield = this->_internal_search_region_3(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .roborts_decision.Point search_region_4 = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_search_region_4_size()); i < n; i++) {
    const auto& repfield = this->_internal_search_region_4(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_decision.DecisionConfig)
  return target;
}

size_t DecisionConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_decision.DecisionConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .roborts_decision.Point point = 1;
  total_size += 1UL * this->_internal_point_size();
  for (const auto& msg : this->_impl_.point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .roborts_decision.Point buff_point = 5;
  total_size += 1UL * this->_internal_buff_point_size();
  for (const auto& msg : this->_impl_.buff_point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .roborts_decision.Point search_region_1 = 11;
  total_size += 1UL * this->_internal_search_region_1_size();
  for (const auto& msg : this->_impl_.search_region_1_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .roborts_decision.Point search_region_2 = 12;
  total_size += 1UL * this->_internal_search_region_2_size();
  for (const auto& msg : this->_impl_.search_region_2_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .roborts_decision.Point search_region_3 = 13;
  total_size += 1UL * this->_internal_search_region_3_size();
  for (const auto& msg : this->_impl_.search_region_3_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .roborts_decision.Point search_region_4 = 14;
  total_size += 1UL * this->_internal_search_region_4_size();
  for (const auto& msg : this->_impl_.search_region_4_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .roborts_decision.EscapeConstraint escape = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.escape_);
    }

    // optional .roborts_decision.SearchConstraint search_limit = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.search_limit_);
    }

    // optional .roborts_decision.WhirlVel whirl_vel = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.whirl_vel_);
    }

    // optional .roborts_decision.MultiRobot wing_bot = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wing_bot_);
    }

    // optional .roborts_decision.MultiRobot master_bot = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.master_bot_);
    }

    // optional .roborts_decision.Point wing_bot_task_point = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wing_bot_task_point_);
    }

    // optional bool simulate = 2 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool master = 3 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecisionConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DecisionConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecisionConfig::GetClassData() const { return &_class_data_; }


void DecisionConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DecisionConfig*>(&to_msg);
  auto& from = static_cast<const DecisionConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:roborts_decision.DecisionConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.point_.MergeFrom(from._impl_.point_);
  _this->_impl_.buff_point_.MergeFrom(from._impl_.buff_point_);
  _this->_impl_.search_region_1_.MergeFrom(from._impl_.search_region_1_);
  _this->_impl_.search_region_2_.MergeFrom(from._impl_.search_region_2_);
  _this->_impl_.search_region_3_.MergeFrom(from._impl_.search_region_3_);
  _this->_impl_.search_region_4_.MergeFrom(from._impl_.search_region_4_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_escape()->::roborts_decision::EscapeConstraint::MergeFrom(
          from._internal_escape());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_search_limit()->::roborts_decision::SearchConstraint::MergeFrom(
          from._internal_search_limit());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_whirl_vel()->::roborts_decision::WhirlVel::MergeFrom(
          from._internal_whirl_vel());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_wing_bot()->::roborts_decision::MultiRobot::MergeFrom(
          from._internal_wing_bot());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_master_bot()->::roborts_decision::MultiRobot::MergeFrom(
          from._internal_master_bot());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_wing_bot_task_point()->::roborts_decision::Point::MergeFrom(
          from._internal_wing_bot_task_point());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.simulate_ = from._impl_.simulate_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.master_ = from._impl_.master_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecisionConfig::CopyFrom(const DecisionConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_decision.DecisionConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecisionConfig::IsInitialized() const {
  return true;
}

void DecisionConfig::InternalSwap(DecisionConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.point_.InternalSwap(&other->_impl_.point_);
  _impl_.buff_point_.InternalSwap(&other->_impl_.buff_point_);
  _impl_.search_region_1_.InternalSwap(&other->_impl_.search_region_1_);
  _impl_.search_region_2_.InternalSwap(&other->_impl_.search_region_2_);
  _impl_.search_region_3_.InternalSwap(&other->_impl_.search_region_3_);
  _impl_.search_region_4_.InternalSwap(&other->_impl_.search_region_4_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecisionConfig, _impl_.master_)
      + sizeof(DecisionConfig::_impl_.master_)
      - PROTOBUF_FIELD_OFFSET(DecisionConfig, _impl_.escape_)>(
          reinterpret_cast<char*>(&_impl_.escape_),
          reinterpret_cast<char*>(&other->_impl_.escape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecisionConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_decision_2eproto_getter, &descriptor_table_decision_2eproto_once,
      file_level_metadata_decision_2eproto[5]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace roborts_decision
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::roborts_decision::Point*
Arena::CreateMaybeMessage< ::roborts_decision::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_decision::EscapeConstraint*
Arena::CreateMaybeMessage< ::roborts_decision::EscapeConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::EscapeConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_decision::SearchConstraint*
Arena::CreateMaybeMessage< ::roborts_decision::SearchConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::SearchConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_decision::WhirlVel*
Arena::CreateMaybeMessage< ::roborts_decision::WhirlVel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::WhirlVel >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_decision::MultiRobot*
Arena::CreateMaybeMessage< ::roborts_decision::MultiRobot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::MultiRobot >(arena);
}
template<> PROTOBUF_NOINLINE ::roborts_decision::DecisionConfig*
Arena::CreateMaybeMessage< ::roborts_decision::DecisionConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::roborts_decision::DecisionConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
